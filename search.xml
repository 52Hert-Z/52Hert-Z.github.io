<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/25/hello-world/"/>
      <url>/2021/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="测试一下mermaid插件">测试一下mermaid插件</h3><div class="mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</div><h3 id="测试一下公式">测试一下公式</h3><p>$$<br>\lim_{x\rightarrow 0}\left ( 1+x \right )^{\frac{1}{x}}=e<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第二章笔记</title>
      <link href="/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第二章 线性表</h1><div class="mermaid">graph TD;    线性表--&gt;顺序存储;线性表--&gt;链式存储;    链式存储--&gt;单链表;    链式存储--&gt;双链表;    链式存储--&gt;循环链表;    链式存储--&gt;静态链表;    单链表--&gt;指针实现;    双链表--&gt;指针实现;    循环链表--&gt;指针实现;</div><ul><li><p>线性表是算法题命题的重点。实现容易代码量少，但是同时也要求有最优的性能（时间复杂度和空间复杂度），才能拿满分。</p></li><li><p>考试中不要求代码有实际的可执行性，只要表达出算法的思想即可，不要死抠语法细节。</p></li><li><p>在考场上实在想不出来最优解可以采用暴力解也能拿至少一半分数。</p></li></ul><h2 id="线性表的类型定义">线性表的类型定义</h2><ol><li>线性结构特点：</li></ol><ul><li>存在唯一的一个被称作“第一个”的数据元素；</li><li>除第一个之外，集合中的每一个数据元素都只有一个前驱；</li><li>除了最后一个之外，集合中的每个数据元素都只有一个后继。</li></ul><ol start="2"><li><strong>线性表</strong>是最常用且最简单的一种数据结构。<br>线性表是有n个数据元素的有限序列，这里的数据元素可以是简单的int型整数，也可以是一个结构体，由若干个数据项组成，比如说链表，含有数据域以及指针域。<br>在这种情况下，数据元素可以叫做记录，含有大量记录的线性表叫做<strong>文件</strong>。</li><li>线性表特点</li></ol><ul><li>元素个数有限</li><li>表中元素具有先后次序</li><li>元素数据类型都相同</li><li>元素具有抽象性，仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容</li></ul><h2 id="线性表的顺序表示和实现">线性表的顺序表示和实现</h2><h3 id="顺序表定义">顺序表定义</h3><ol><li>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得在逻辑上相邻的两个元素在物理上也相邻。</li><li>顺序表的特点就是表中元素的逻辑顺序和物理顺序相同。</li><li><strong>位序</strong>：数组下标加一，即表示实际第几个元素（从一开始计数）</li><li>线性表顺序存储实现</li></ol><ul><li>静态分配（长度不可变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype data[MaxSize];<span class="comment">//顺序表元素</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;Sqlist;<span class="comment">//把struct换个名字</span></span><br></pre></td></tr></table></figure><ul><li>动态分配（长度可以变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype *data;</span><br><span class="line">  <span class="keyword">int</span> length, MaxSize;<span class="comment">//length：当前元素个数，MaxSize：数组最大长度（随着需要可以改变）</span></span><br><span class="line">&#125;Sqlist;</span><br><span class="line">L.data=(Elemtype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elemtype));<span class="comment">//C语言分配内存空间</span></span><br><span class="line">L.data=<span class="keyword">new</span> Elemtype[InitSize];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意C语言调用malloc函数要包含 <strong>#include&lt;stdlib.h&gt;</strong></p><ol start="5"><li>顺序表特点</li></ol><ul><li>最大特点是随机访问</li><li>存储密度高</li><li>插入删除要移动大量元素</li></ul><h3 id="顺序表基本操作实现">顺序表基本操作实现</h3><ol><li>插入操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(L.length&gt;=MaxSize)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/*注意这里判断插入位置i可以到length+1因为可以在这个位置插入（位序）</span></span><br><span class="line"><span class="comment">  而下面的移动元素数组的下标最多到length，此时数组里最后一个元素的下标是length-1</span></span><br><span class="line"><span class="comment">  因为要往后移动元素，所以要用到第length个数组位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=L.length;j&gt;=i;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j<span class="number">-1</span>];<span class="comment">//从第i个元素开始往后移动，这样数组里面L.data[i-1]就会空出来</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑时间复杂度为 $O(N)$。注意计算移动节点的平均次数。</p><ol start="2"><li>删除操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e=L.data[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&lt;L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j+<span class="number">1</span>];<span class="comment">//将第i个元素之后的元素前移</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意计算移动节点的平均次数。</p><ol start="3"><li>按值查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(Sqlist L, Elemtype e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意查找的平均比较次数。</p><h2 id="线性表的链式表示和实现">线性表的链式表示和实现</h2><p>显然，顺序表在插入删除方面有不可避免的缺点，所以链式存储应运而生，解决这个问题，但也失去了顺序存储的随机访问的优点。</p><p>线性表的链式存储也叫链表。</p><h3 id="单链表的定义">单链表的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  Elemtype data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*LinkList -&gt; LNode*</span></span><br><span class="line"><span class="comment">LinkList L;</span></span><br><span class="line"><span class="comment">LNode* L;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意这里的重命名，我们声明了一个叫做LNode的结构体，然后我们给他换个名字叫LNode，以及声明一个它的指针类型。</p><ol><li>头指针与头结点</li></ol><ul><li>头指针：指向链表第一个结点的指针，跟有没有头结点没有关系</li><li>头结点：有些定义为了方便操作，在第一个结点之前定义了一个叫做头结点的东西，该节点的指针指向第一个结点，头结点的数据域可以不存储东西，也可以存储比如说链表长度之类的东西</li></ul><ol start="2"><li>头结点的好处</li></ol><ul><li>第一个节点不用特殊处理（因为第一个节点跟其他节点一样，他的位置存放在上一个节点的next指针里，如果不使用头结点，那么第一个节点就要特殊处理，做题的时候注意审题），比如说在第一个结点前插入新节点或者说删除第一个结点我们都需要更改头指针的指向，非常麻烦。</li><li>非空表和空表的处理得到统一（因为无论是不是空表，头指针都是非空的），比如说一个不带头结点的空链表要插入一个结点，不带头结点的链表在第一个位置插入新节点，虽然都是在同一个位置插入，但是操作是不一样的，非常麻烦，容易出bug</li><li>总的来说就是没有头结点的时候，对于第一个结点的操作跟其他节点都是不一样的，每个操作都要考虑特殊情况，有头结点就没这么多鸟事</li></ul><ol start="3"><li>头插法建立单链表</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L-&gt;next;<span class="comment">//两步指针插入</span></span><br><span class="line">    L-&gt;next=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L;<span class="comment">//两步指针插入</span></span><br><span class="line">    L=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要创建头结点以及插入的时候先指向头指针所指向的节点（第一个结点），然后再将头指针指向新节点。</p><p>需要注意的是，头插法输入数据的顺序跟在链表中的顺序是相反的，可以用来将元素逆序。</p><ol start="4"><li>尾插法</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  LNode *s, *r=L;<span class="comment">//r为表尾指针</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    r-&gt;next=s;<span class="comment">//两步指针插入</span></span><br><span class="line">    r=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><p>思考</p><ol start="5"><li>按位查找</li><li>按值查找</li><li>插入结点</li><li>删除结点</li><li>求表长</li></ol><h3 id="双链表">双链表</h3><p>单链表有个缺点就是要找一个结点的前驱非常麻烦，要从头遍历，所以有了双链表，在结构体的指针域中增加一个指向前一个结点的指针，注意头结点的前驱指针指向空。</p><ol><li>插入</li><li>删除</li></ol><h3 id="循环链表">循环链表</h3><h4 id="循环单链表">循环单链表</h4><p>与单链表唯一的不同就是尾结点的next指针指向了头结点，变成了一个环。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
