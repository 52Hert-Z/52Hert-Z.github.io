<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构第三章笔记</title>
      <link href="/2021/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2021/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第三章 栈和队列</h1><h2 id="复习时间轴">复习时间轴</h2><p><strong>6.28-29</strong>：看书复习、王道数据结构复习书相应部分并做题</p><ul><li>3.1.1 栈的定义和特点</li><li>3.1.2 栈的表示和操作实现</li><li>3.1.3 栈的应用：递归实现</li></ul><h2 id="知识框架">知识框架</h2><div class="mermaid">graph LR;    线性表--&gt;栈;线性表--&gt;队列;    线性表--&gt;数组;    栈--&gt;顺序栈;    栈--&gt;链栈;    栈--&gt;共享栈;    队列--&gt;循环队列;    队列--&gt;链式队列;    队列--&gt;双端队列;    数组--&gt;一维数组;    数组--&gt;多维数组;</div><h2 id="复习要点">复习要点</h2><ul><li>本章通常是考选择题，题目不难但是命题形式比较灵活，其中栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征是重点。由于它们是线性表的应用和推广，因此也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是必须掌握的内容。</li><li>线性表的应用以表的合并为重点，不仅要学会算法的实现，也要掌握合并算法复杂度的分析</li><li>递归是栈的最常见应用，结合算法实例理解</li></ul><h2 id="栈">栈</h2><ol><li>n个不同元素进栈，出栈元素不同排列的个数为卡特兰数：$\frac{1}{n+1}C_{2n}^{n}$</li><li>栈的基本操作</li></ol><h3 id="栈的顺序存储（顺序栈）">栈的顺序存储（顺序栈）</h3><p>采用顺序存储的栈叫做顺序栈，存储地址连续，设定top指针</p><ul><li>静态分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><ul><li>动态分配<br>因为栈在使用过程中所需最大空间的大小很难估计，因此一般来说，在初始化设定栈的时候不应该限定栈的最大容量，一个较合理的做法是：先分配一个初始容量，然后随着使用需要更多空间再重新分配。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype *base;</span><br><span class="line">    Elemtype *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>base叫做栈底指针，在顺序栈中，它始终指向栈底的位置，若base的值为NULL，则栈不存在（不代表栈为空），top为栈顶指针，初始化栈时会分配一个起始地址给top，并将base=top，即top=base为栈空条件</p><h3 id="栈的链式存储">栈的链式存储</h3><p>叫做链栈，优点是便于多个栈共享同一块存储空间和提高效率，不存在栈满上溢的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure><h3 id="栈的操作">栈的操作</h3><h4 id="初始化InitStack">初始化InitStack</h4><ul><li>静态分配<br>将top置为-1即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态分配<br>要分配空间，还要进行判断是否初始化成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(Elemtype*)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">    <span class="keyword">if</span>(S.base==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=InitSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈">进栈</h4><h4 id="出栈">出栈</h4><h4 id="判断栈空">判断栈空</h4><h4 id="读栈顶元素">读栈顶元素</h4><h3 id="共享栈">共享栈</h3><h3 id="栈的应用">栈的应用</h3><h4 id="数制转换">数制转换</h4><p>因为辗转相除法最后逆序正好符合了栈的LIFO的特点，所以可以用栈实现数制转换</p><h4 id="括号匹配">括号匹配</h4><p>因为括号后面出现的右括号也是要先匹配前面最后一个左括号，也就是栈顶括号，也符合</p><h4 id="行编辑程序">行编辑程序</h4><p>用来设定输入缓冲区，根据栈顶是不是特殊字符判断什么操作</p><h4 id="迷宫求解">迷宫求解</h4><h4 id="表达式求值">表达式求值</h4><p>中缀表达式可以用符号栈和操作数栈分开</p><h3 id="函数调用栈">函数调用栈</h3><p>这个栈每个节点存储返回地址以及参数值</p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组第一章笔记</title>
      <link href="/2021/06/29/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/06/29/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>复习要点</h1><p>本章是组成原理的概述，考察时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。重点在各个性能指标的计算，这部分考频很高。</p><ul><li>计算机由哪几部分组成？以哪部分为中心？</li><li>主频高的CPU一定比主频低的CPU快吗？为什么？</li><li>翻译程序、汇编程序、编译程序、解释程序有什么区别？各自的特性是什么？</li><li>不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</li></ul><h1>第一章 计算机系统概述</h1><p>三极管：高低电平控制导不导通，作为开关，表示计算机的0个1实现基本操作，实现与门、或门、异或门等<br>可以用来实现加法操作加减乘除都行</p><h2 id="计算机发展历程">计算机发展历程</h2><h3 id="计算机硬件的发展">计算机硬件的发展</h3><ol><li>ENIAC：1946第一台电子数字计算机，电子管时代（1946-1957）<br>特点：</li></ol><ul><li>逻辑元件采用电子管</li><li>使用机器语言进行编程</li><li>主存用延迟线或磁鼓存储信息，容量极小</li><li>体积庞大</li><li>运算速度较低，一般只有几千次到几万次每秒</li></ul><ol start="2"><li>第二代计算机：1958-1964，晶体管时代<br>特点：</li></ol><ul><li>逻辑元件采用晶体管</li><li>运算速度提高到几万次到几十万次</li></ul><h3 id="计算机软件的发展">计算机软件的发展</h3><p>比较次要，考的比较少</p><h2 id="计算机系统层次结构">计算机系统层次结构</h2><h3 id="计算机系统的构成">计算机系统的构成</h3><p>存储器的工作方式是按存储单元的地址存取<br>MDR的长度等于存储单元的长度，称之为存储字长（字），即存储单元中存储基元的个数<br>存储字长可以是8位、16位、32位等，字节的二次幂的整数倍<br>每8个存储基元称之为一个字节，存储字长为字节的整数倍<br>位bit<br>字节byte<br>字word<br>MQ乘商寄存器<br>ACC累加器<br>ALU算术逻辑单元<br>X操作数寄存器<br>CU控制单元<br>IR指令寄存器：存放当前的指令<br>PC程序计数器：存放当前想要执行的指令的地址</p><h3 id="计算机硬件的基本组成">计算机硬件的基本组成</h3><p>冯诺依曼计算机结构：</p><ul><li>计算机由运算器、存储器、控制器、输入和输出设备五大部分组成</li><li>指令和数据以同等地为存放在存储器内，并可按地址寻访</li><li>指令和数据均采用二进制来表示</li><li>指令游操作码和地址码组成</li><li>指令在存储器内顺序存放。通常指顺序执行，在特定条件下，可根据运算结果或条件改变执行顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传输通过运算器完成<br>计算机软件和硬件的关系：</li><li>硬件和软件互相依存<br>硬件是软件工作的物质基础，软件的正常工作是硬件发挥作用的唯一途径</li><li>硬件和软件无严格界线<br>在许多情况下，计算机的某些功能既可以由硬件实现，也可以由软件来实现。因此，硬件与软件在一定意义上说没有严格的界线</li><li>硬件和软件协同发展<br>计算机软件随硬件技术的发展而发展，而软件的不断发展与完善又促进硬件的更新，两者交织发展，缺一不可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研408 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组复习计划</title>
      <link href="/2021/06/29/%E8%AE%A1%E7%BB%84%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2021/06/29/%E8%AE%A1%E7%BB%84%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>总体规划</h1><ul><li>组成原理在计算机考研中非常重要，特别是针对 408 的考试，组成原理分值占 45 分，和数据结构并驾齐驱。在这门课程中，我们需要理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有计算机系统的整机概念。理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。这门课程是非记忆性的，侧重概念和原理的应用，各个章节之间也是紧密联系的，同学们要学会把所有的内容都串起来。</li><li>第一章计算机系统概述。这一章初步了解计算机执行的基本过程，这个过程贯彻到后面的各个章节，所以一定要理解透。</li><li>第二章数据的表示和运算。这一章主要有四部分内容，数制与编码、定点数的表示和运算、浮点数的表示和运算和算术逻辑单元 ALU，这一章内容比较零碎、也比较枯燥无聊，希望同学们多理解。</li><li>第三章存储器层次结构。这一章是重点章节，存储器的分类、存储器的层次结化结构、 半导体随机存取存储器主要考察概念。重点在主存储器与 CPU 的连接以及高速缓冲存储器两大块。另外，虚拟存储器有些自主命题的院校不考可以不看，408 命题喜欢将虚拟存储器和 OS 联合出题，同学们一定要重视。</li><li>第四章指令系统也是一大块考点，这一章通常会结合 CPU 系统进行考察。其中指令的寻址方式是重中之重。</li><li>第五章中央处理器是计算机的中心,也是本书的难点。其中,数据通路的分析、指令执行 阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特 点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。 但是针对不同学校第四章和第五章可能会有偏差，希望同学们参考院校大纲，有计划地进行 学习。</li><li>第六章总线的知识点较少，其中总线仲裁及总线操作和定时方式是难点。本章内容通常 以选择题的形式出现，特别是系统总线的特点、性能指标、各种仲裁方式的特点、异步定时 方式及常见的总线标准和特点等。总线带宽的计算也可能结合其他章节出综合题。</li><li>第七章结合操作系统《输入输出 I/O 管理》一起复习，磁盘存储、I/O 接口、中断以及 I/O 方式是本章节的重点。</li></ul><h1>复习要点</h1><p>六月到七月是复习计组的第一轮，复习方法偏重基础</p><ul><li>课本为主，在复习时勾画知识点，圈出重难点</li><li>看网课做好笔记，重点解决标注的重难点</li><li>课后练习有针对性做题（做好王道课后题就完事），多总结</li></ul><h1>复习进度</h1><div class="mermaid">gantt    title 计组复习进度    dateFormat YYYY-MM-DD    section 复习章节        第一章  :done, des1, 2021-06-29, 2021-06-30        第二章  :active, des2, 2021-06-30, 2021-07-01        第三章  :des3, 2021-07-01, 2021-07-02        第四章  :des4, 2021-07-02, 2021-07-08</div><ul><li>6.29 第一章计算机系统概述，看网课，王道计组复习书</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研408 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/25/hello-world/"/>
      <url>/2021/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>写在前面</h1><p>最近一时兴起想要建个博客，用了Jerry的butterfly框架，平时记录一下笔记，以及一些脑子一热的想法。</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="测试一下mermaid插件">测试一下mermaid插件</h3><div class="mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</div><div class="mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 计组章节        Completed task            :done,    des1, 2014-01-06,2014-01-08        Active task               :active,  des2, 2014-01-09, 3d        Future task               :         des3, after des2, 5d        Future task2               :         des4, after des3, 5d        section Critical tasks        Completed task in the critical line :crit, done, 2014-01-06,24h        Implement parser and jison          :crit, done, after des1, 2d        Create tests for parser             :crit, active, 3d        Future task in critical line        :crit, 5d        Create tests for renderer           :2d        Add to mermaid                      :1d        section Documentation        Describe gantt syntax               :active, a1, after des1, 3d        Add gantt diagram to demo page      :after a1  , 20h        Add another diagram to demo page    :doc1, after a1  , 48h        section Last section        Describe gantt syntax               :after doc1, 3d        Add gantt diagram to demo page      : 20h        Add another diagram to demo page    : 48h</div><h3 id="测试一下公式">测试一下公式</h3><p>$$<br>\lim_{x\rightarrow 0}\left ( 1+x \right )^{\frac{1}{x}}=e<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第二章笔记</title>
      <link href="/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第二章 线性表</h1><div class="mermaid">graph TD;    线性表--&gt;顺序存储;线性表--&gt;链式存储;    链式存储--&gt;单链表;    链式存储--&gt;双链表;    链式存储--&gt;循环链表;    链式存储--&gt;静态链表;    单链表--&gt;指针实现;    双链表--&gt;指针实现;    循环链表--&gt;指针实现;</div><ul><li><p>线性表是算法题命题的重点。实现容易代码量少，但是同时也要求有最优的性能（时间复杂度和空间复杂度），才能拿满分。</p></li><li><p>考试中不要求代码有实际的可执行性，只要表达出算法的思想即可，不要死抠语法细节。</p></li><li><p>在考场上实在想不出来最优解可以采用暴力解也能拿至少一半分数。</p></li></ul><h2 id="线性表的类型定义">线性表的类型定义</h2><ol><li>线性结构特点：</li></ol><ul><li>存在唯一的一个被称作“第一个”的数据元素；</li><li>除第一个之外，集合中的每一个数据元素都只有一个前驱；</li><li>除了最后一个之外，集合中的每个数据元素都只有一个后继。</li></ul><ol start="2"><li><strong>线性表</strong>是最常用且最简单的一种数据结构。<br>线性表是有n个数据元素的有限序列，这里的数据元素可以是简单的int型整数，也可以是一个结构体，由若干个数据项组成，比如说链表，含有数据域以及指针域。<br>在这种情况下，数据元素可以叫做记录，含有大量记录的线性表叫做<strong>文件</strong>。</li><li>线性表特点</li></ol><ul><li>元素个数有限</li><li>表中元素具有先后次序</li><li>元素数据类型都相同</li><li>元素具有抽象性，仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容</li></ul><h2 id="线性表的顺序表示和实现">线性表的顺序表示和实现</h2><h3 id="顺序表定义">顺序表定义</h3><ol><li>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得在逻辑上相邻的两个元素在物理上也相邻。</li><li>顺序表的特点就是表中元素的逻辑顺序和物理顺序相同。</li><li><strong>位序</strong>：数组下标加一，即表示实际第几个元素（从一开始计数）</li><li>线性表顺序存储实现</li></ol><ul><li>静态分配（长度不可变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype data[MaxSize];<span class="comment">//顺序表元素</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;Sqlist;<span class="comment">//把struct换个名字</span></span><br></pre></td></tr></table></figure><ul><li>动态分配（长度可以变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype *data;</span><br><span class="line">  <span class="keyword">int</span> length, MaxSize;<span class="comment">//length：当前元素个数，MaxSize：数组最大长度（随着需要可以改变）</span></span><br><span class="line">&#125;Sqlist;</span><br><span class="line">L.data=(Elemtype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elemtype));<span class="comment">//C语言分配内存空间</span></span><br><span class="line">L.data=<span class="keyword">new</span> Elemtype[InitSize];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意C语言调用malloc函数要包含 <strong>#include&lt;stdlib.h&gt;</strong></p><ol start="5"><li>顺序表特点</li></ol><ul><li>最大特点是随机访问</li><li>存储密度高</li><li>插入删除要移动大量元素</li></ul><h3 id="顺序表基本操作实现">顺序表基本操作实现</h3><ol><li>插入操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(L.length&gt;=MaxSize)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/*注意这里判断插入位置i可以到length+1因为可以在这个位置插入（位序）</span></span><br><span class="line"><span class="comment">  而下面的移动元素数组的下标最多到length，此时数组里最后一个元素的下标是length-1</span></span><br><span class="line"><span class="comment">  因为要往后移动元素，所以要用到第length个数组位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=L.length;j&gt;=i;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j<span class="number">-1</span>];<span class="comment">//从第i个元素开始往后移动，这样数组里面L.data[i-1]就会空出来</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑时间复杂度为 $O(N)$。注意计算移动节点的平均次数。</p><ol start="2"><li>删除操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e=L.data[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&lt;L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j+<span class="number">1</span>];<span class="comment">//将第i个元素之后的元素前移</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意计算移动节点的平均次数。</p><ol start="3"><li>按值查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(Sqlist L, Elemtype e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意查找的平均比较次数。</p><h2 id="线性表的链式表示和实现">线性表的链式表示和实现</h2><p>显然，顺序表在插入删除方面有不可避免的缺点，所以链式存储应运而生，解决这个问题，但也失去了顺序存储的随机访问的优点。</p><p>线性表的链式存储也叫链表。</p><h3 id="单链表的定义">单链表的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  Elemtype data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*LinkList -&gt; LNode*</span></span><br><span class="line"><span class="comment">LinkList L;</span></span><br><span class="line"><span class="comment">LNode* L;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意这里的重命名，我们声明了一个叫做LNode的结构体，然后我们给他换个名字叫LNode，以及声明一个它的指针类型。</p><ol><li>头指针与头结点</li></ol><ul><li>头指针：指向链表第一个结点的指针，跟有没有头结点没有关系</li><li>头结点：有些定义为了方便操作，在第一个结点之前定义了一个叫做头结点的东西，该节点的指针指向第一个结点，头结点的数据域可以不存储东西，也可以存储比如说链表长度之类的东西</li></ul><ol start="2"><li>头结点的好处</li></ol><ul><li>第一个节点不用特殊处理（因为第一个节点跟其他节点一样，他的位置存放在上一个节点的next指针里，如果不使用头结点，那么第一个节点就要特殊处理，做题的时候注意审题），比如说在第一个结点前插入新节点或者说删除第一个结点我们都需要更改头指针的指向，非常麻烦。</li><li>非空表和空表的处理得到统一（因为无论是不是空表，头指针都是非空的），比如说一个不带头结点的空链表要插入一个结点，不带头结点的链表在第一个位置插入新节点，虽然都是在同一个位置插入，但是操作是不一样的，非常麻烦，容易出bug</li><li>总的来说就是没有头结点的时候，对于第一个结点的操作跟其他节点都是不一样的，每个操作都要考虑特殊情况，有头结点就没这么多鸟事</li></ul><ol start="3"><li>头插法建立单链表</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L-&gt;next;<span class="comment">//两步指针插入</span></span><br><span class="line">    L-&gt;next=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L;<span class="comment">//两步指针插入</span></span><br><span class="line">    L=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要创建头结点以及插入的时候先指向头指针所指向的节点（第一个结点），然后再将头指针指向新节点。</p><p>需要注意的是，头插法输入数据的顺序跟在链表中的顺序是相反的，可以用来将元素逆序。</p><ol start="4"><li>尾插法</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  LNode *s, *r=L;<span class="comment">//r为表尾指针</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    r-&gt;next=s;<span class="comment">//两步指针插入</span></span><br><span class="line">    r=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><p>思考</p><ol start="5"><li>按位查找</li><li>按值查找</li><li>插入结点</li><li>删除结点</li><li>求表长</li></ol><h3 id="双链表">双链表</h3><p>单链表有个缺点就是要找一个结点的前驱非常麻烦，要从头遍历，所以有了双链表，在结构体的指针域中增加一个指向前一个结点的指针，注意头结点的前驱指针指向空。</p><ol><li>插入</li><li>删除</li></ol><h3 id="循环链表">循环链表</h3><h4 id="循环单链表">循环单链表</h4><p>与单链表唯一的不同就是尾结点的next指针指向了头结点，变成了一个环。</p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研408 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
