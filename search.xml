<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于政治的一些思考（仅代表个人观点）</title>
      <link href="/2021/07/01/%E6%94%BF%E6%B2%BB%E9%9A%8F%E6%83%B3/"/>
      <url>/2021/07/01/%E6%94%BF%E6%B2%BB%E9%9A%8F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>考研过程中关于一些政治上的问题的自己的思考，仅代表我个人的观点，不保证正确，单纯记录下来自己的看法。🤥</p><hr><h3 id="什么叫做生产关系">什么叫做生产关系</h3><p>生产关系是人们在生产中形成的人和人之间的利益关系。包括三个方面：</p><ul><li>是所有制，这个东西归谁所有</li><li>是在生产当中，人和人之间的地位，是资本主义雇佣劳动的剥削关系，还是一起劳动的共生</li><li>是产品的分配关系，我们生产出来一些东西应该怎么分配，怎么样来分。是按劳分配还是按需分配，还是你拿大头我拿小头，我给你当苦力打工</li></ul><h3 id="怎么理解私人劳动和社会劳动的矛盾决定了商品经济的本质和发展过程">怎么理解私人劳动和社会劳动的矛盾决定了商品经济的本质和发展过程</h3><p>商品经济，也就是交换经济，不同于之前的自给自足，我们劳动为了生产出商品，想要卖给别人拿到货币再买东西。所以，决定我们是不是会被饿死的关键就是能不能把那些玩意儿卖出去，卖不卖的出去这个问题就是私人劳动能不能转化为社会劳动，也就是说我们的劳动是不是被社会承认，被承认了商品就卖出去了，就完事儿了。呃，在这里这个私人劳动在商品卖出去的同时也就转化为了社会劳动。<br>在这里显然私人劳动能不能转化为社会劳动这个矛盾就决定了我们的命运，也就是商品能不能卖出去。所以这就决定了商品经济的本质。<br>决定发展过程可以这么理解<br>在资本主义社会里，这个比较发达的商品经济中，基本矛盾依然是私人劳动和社会劳动，但是具体到这个阶段的话，就发展为生产资料私人占有和生产社会化之间的矛盾，但是决定生产者的仍然是这个商品能不能卖出去，只不过到资本主义里，买卖很容易，但是社会需求跟个人生产之间出现脱节，能卖出去多少成为了矛盾，这也就决定了商品经济的发展过程</p><h3 id="如何理解商品拜物教">如何理解商品拜物教</h3><p>这个感觉就是跟一种信奉一样，是人们在商品经济中的一种主观感受，人们无法卖出商品就没办法拿到钱，没有钱就没办法买东西。所以人们仿佛被商品扼住了命运的咽喉，被其决定了是生存还是裂开，商品仿佛像是神灵一般决定着人们的命运。因此，在商品经济中，有些人对待商品就好像对待神灵一样敬畏、崇拜，这就叫“商品拜物教”</p><h3 id="资本主义只通过剩余价值赚钱">资本主义只通过剩余价值赚钱</h3><p>比如说资本家花费钱购入原材料、生产家具的机器、厂房等等不变资本，然后花钱雇佣工人来生产家具，也就是可变资本，工人生产出家具被卖出去（精美的家具），我们可以知道精美的家具价格比较昂贵，原材料跟厂房那些成本也肯定比售价便宜很多，也就是实际上是工人劳动的价值给这件商品升值<br>首先资本家是会付给工人工钱的，但是实际上资本家付给工人的只是工人必要劳动的价值，工人还有剩余劳动是白给资本家打工的，比如说一天一百块，实际上工人打工10个小时就值100块，但是一天干了12个小时，这两个小时就是剩余劳动，就是白打工了，这部分劳动的价值给资本家剥削去了，资本家就是通过这一部分的价值赚到了钱</p><h3 id="如何理解共产主义按需分配导致生产发展停滞">如何理解共产主义按需分配导致生产发展停滞</h3><p>我们都知道共产主义是按需分配的，也就是我需要什么我就拿就完事了，那我成天在家好吃懒做不干活儿，社会生产力是不是就会止步不前，这种社会的状态肯定不是发展的终极状态，这是一种病态<br>实际上共产主义社会是建立在生产力极大发展，人民精神境界极大提高的基础之上，共产主义并不是生产力发展到很高程度就不生产了，而是人们已经具备了极高的思想觉悟，把劳动作为了生存的第一需求，每天就会自动自觉地投入到社会生产中去，而不像现在，劳动使人们谋生的手段。所以实际上到了共产主义社会，人人劳动的社会会极大促进生产力发展，并不会停滞<br>但是总感觉这好像乌托邦，太过理想化了</p>]]></content>
      
      
      <categories>
          
          <category> 政治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研政治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习总书记建党100周年讲话</title>
      <link href="/2021/07/01/%E5%BA%86%E7%A5%9D%E5%BB%BA%E5%85%9A/"/>
      <url>/2021/07/01/%E5%BA%86%E7%A5%9D%E5%BB%BA%E5%85%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>习近平：在庆祝中国共产党成立一百周年大会上的讲话</h1><p>同志们，朋友们：<br>今天，在中国共产党历史上，在中华民族历史上，都是一个十分重大而庄严的日子。我们在这里隆重集会，同全党全国各族人民一道，庆祝中国共产党成立一百周年，回顾中国共产党百年奋斗的光辉历程，展望中华民族伟大复兴的光明前景。<br>首先，我代表党中央，向全体中国共产党员致以节日的热烈祝贺！<br>在这里，我代表党和人民庄严宣告，经过全党全国各族人民持续奋斗，我们实现了第一个百年奋斗目标，在中华大地上全面建成了小康社会，历史性地解决了绝对贫困问题，正在意气风发向着全面建成社会主义现代化强国的第二个百年奋斗目标迈进。这是中华民族的伟大光荣！这是中国人民的伟大光荣！这是中国共产党的伟大光荣！<br>同志们、朋友们！<br>中华民族是世界上伟大的民族，有着5000多年源远流长的文明历史，为人类文明进步作出了不可磨灭的贡献。1840年鸦片战争以后，中国逐步成为半殖民地半封建社会，国家蒙辱、人民蒙难、文明蒙尘，中华民族遭受了前所未有的劫难。从那时起，实现中华民族伟大复兴，就成为中国人民和中华民族最伟大的梦想。<br>为了拯救民族危亡，中国人民奋起反抗，仁人志士奔走呐喊，太平天国运动、戊戌变法、义和团运动、辛亥革命接连而起，各种救国方案轮番出台，但都以失败而告终。中国迫切需要新的思想引领救亡运动，迫切需要新的组织凝聚革命力量。<br>十月革命一声炮响，给中国送来了马克思列宁主义。在中国人民和中华民族的伟大觉醒中，在马克思列宁主义同中国工人运动的紧密结合中，中国共产党应运而生。中国产生了共产党，这是开天辟地的大事变，深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局。<br>中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心使命。一百年来，中国共产党团结带领中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题：实现中华民族伟大复兴。<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，浴血奋战、百折不挠，创造了新民主主义革命的伟大成就。我们经过北伐战争、土地革命战争、抗日战争、解放战争，以武装的革命反对武装的反革命，推翻帝国主义、封建主义、官僚资本主义三座大山，建立了人民当家作主的中华人民共和国，实现了民族独立、人民解放。新民主主义革命的胜利，彻底结束了旧中国半殖民地半封建社会的历史，彻底结束了旧中国一盘散沙的局面，彻底废除了列强强加给中国的不平等条约和帝国主义在中国的一切特权，为实现中华民族伟大复兴创造了根本社会条件。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，中国人民站起来了，中华民族任人宰割、饱受欺凌的时代一去不复返了！<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，自力更生、发愤图强，创造了社会主义革命和建设的伟大成就。我们进行社会主义革命，消灭在中国延续几千年的封建剥削压迫制度，确立社会主义基本制度，推进社会主义建设，战胜帝国主义、霸权主义的颠覆破坏和武装挑衅，实现了中华民族有史以来最为广泛而深刻的社会变革，实现了一穷二白、人口众多的东方大国大步迈进社会主义社会的伟大飞跃，为实现中华民族伟大复兴奠定了根本政治前提和制度基础。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，中国人民不但善于破坏一个旧世界、也善于建设一个新世界，只有社会主义才能救中国，只有社会主义才能发展中国！<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，解放思想、锐意进取，创造了改革开放和社会主义现代化建设的伟大成就。我们实现新中国成立以来党的历史上具有深远意义的伟大转折，确立党在社会主义初级阶段的基本路线，坚定不移推进改革开放，战胜来自各方面的风险挑战，开创、坚持、捍卫、发展中国特色社会主义，实现了从高度集中的计划经济体制到充满活力的社会主义市场经济体制、从封闭半封闭到全方位开放的历史性转变，实现了从生产力相对落后的状况到经济总量跃居世界第二的历史性突破，实现了人民生活从温饱不足到总体小康、奔向全面小康的历史性跨越，为实现中华民族伟大复兴提供了充满新的活力的体制保证和快速发展的物质条件。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，改革开放是决定当代中国前途命运的关键一招，中国大踏步赶上了时代！<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，自信自强、守正创新，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，创造了新时代中国特色社会主义的伟大成就。党的十八大以来，中国特色社会主义进入新时代，我们坚持和加强党的全面领导，统筹推进“五位一体”总体布局、协调推进“四个全面”战略布局，坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化，坚持依规治党、形成比较完善的党内法规体系，战胜一系列重大风险挑战，实现第一个百年奋斗目标，明确实现第二个百年奋斗目标的战略安排，党和国家事业取得历史性成就、发生历史性变革，为实现中华民族伟大复兴提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，中华民族迎来了从站起来、富起来到强起来的伟大飞跃，实现中华民族伟大复兴进入了不可逆转的历史进程！<br>一百年来，中国共产党团结带领中国人民，以“为有牺牲多壮志，敢教日月换新天”的大无畏气概，书写了中华民族几千年历史上最恢宏的史诗。这一百年来开辟的伟大道路、创造的伟大事业、取得的伟大成就，必将载入中华民族发展史册、人类文明发展史册！<br>同志们、朋友们！<br>一百年前，中国共产党的先驱们创建了中国共产党，形成了坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，这是中国共产党的精神之源。<br>一百年来，中国共产党弘扬伟大建党精神，在长期奋斗中构建起中国共产党人的精神谱系，锤炼出鲜明的政治品格。历史川流不息，精神代代相传。我们要继续弘扬光荣传统、赓续红色血脉，永远把伟大建党精神继承下去、发扬光大！<br>同志们、朋友们！<br>一百年来，我们取得的一切成就，是中国共产党人、中国人民、中华民族团结奋斗的结果。以毛泽东同志、邓小平同志、江泽民同志、胡锦涛同志为主要代表的中国共产党人，为中华民族伟大复兴建立了彪炳史册的伟大功勋！我们向他们表示崇高的敬意！<br>此时此刻，我们深切怀念为中国革命、建设、改革，为中国共产党建立、巩固、发展作出重大贡献的毛泽东、周恩来、刘少奇、朱德、邓小平、陈云同志等老一辈革命家，深切怀念为建立、捍卫、建设新中国英勇牺牲的革命先烈，深切怀念为改革开放和社会主义现代化建设英勇献身的革命烈士，深切怀念近代以来为民族独立和人民解放顽强奋斗的所有仁人志士。他们为祖国和民族建立的丰功伟绩永载史册！他们的崇高精神永远铭记在人民心中！<br>人民是历史的创造者，是真正的英雄。我代表党中央，向全国广大工人、农民、知识分子，向各民主党派和无党派人士、各人民团体、各界爱国人士，向人民解放军指战员、武警部队官兵、公安干警和消防救援队伍指战员，向全体社会主义劳动者，向统一战线广大成员，致以崇高的敬意！向香港特别行政区同胞、澳门特别行政区同胞和台湾同胞以及广大侨胞，致以诚挚的问候！向一切同中国人民友好相处，关心和支持中国革命、建设、改革事业的各国人民和朋友，致以衷心的谢意！<br>同志们、朋友们！<br>初心易得，始终难守。以史为鉴，可以知兴替。我们要用历史映照现实、远观未来，从中国共产党的百年奋斗中看清楚过去我们为什么能够成功、弄明白未来我们怎样才能继续成功，从而在新的征程上更加坚定、更加自觉地牢记初心使命、开创美好未来。<br>——以史为鉴、开创未来，必须坚持中国共产党坚强领导。办好中国的事情，关键在党。中华民族近代以来180多年的历史、中国共产党成立以来100年的历史、中华人民共和国成立以来70多年的历史都充分证明，没有中国共产党，就没有新中国，就没有中华民族伟大复兴。历史和人民选择了中国共产党。中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，是党和国家的根本所在、命脉所在，是全国各族人民的利益所系、命运所系。<br>新的征程上，我们必须坚持党的全面领导，不断完善党的领导，增强“四个意识”、坚定“四个自信”、做到“两个维护”，牢记“国之大者”，不断提高党科学执政、民主执政、依法执政水平，充分发挥党总揽全局、协调各方的领导核心作用！<br>——以史为鉴、开创未来，必须团结带领中国人民不断为美好生活而奋斗。江山就是人民、人民就是江山，打江山、守江山，守的是人民的心。中国共产党根基在人民、血脉在人民、力量在人民。中国共产党始终代表最广大人民根本利益，与人民休戚与共、生死相依，没有任何自己特殊的利益，从来不代表任何利益集团、任何权势团体、任何特权阶层的利益。任何想把中国共产党同中国人民分割开来、对立起来的企图，都是绝不会得逞的！9500多万中国共产党人不答应！14亿多中国人民也不答应！<br>新的征程上，我们必须紧紧依靠人民创造历史，坚持全心全意为人民服务的根本宗旨，站稳人民立场，贯彻党的群众路线，尊重人民首创精神，践行以人民为中心的发展思想，发展全过程人民民主，维护社会公平正义，着力解决发展不平衡不充分问题和人民群众急难愁盼问题，推动人的全面发展、全体人民共同富裕取得更为明显的实质性进展！<br>——以史为鉴、开创未来，必须继续推进马克思主义中国化。马克思主义是我们立党立国的根本指导思想，是我们党的灵魂和旗帜。中国共产党坚持马克思主义基本原理，坚持实事求是，从中国实际出发，洞察时代大势，把握历史主动，进行艰辛探索，不断推进马克思主义中国化时代化，指导中国人民不断推进伟大社会革命。中国共产党为什么能，中国特色社会主义为什么好，归根到底是因为马克思主义行！<br>新的征程上，我们必须坚持马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观，全面贯彻新时代中国特色社会主义思想，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，用马克思主义观察时代、把握时代、引领时代，继续发展当代中国马克思主义、21世纪马克思主义！ ——以史为鉴、开创未来，必须坚持和发展中国特色社会主义。走自己的路，是党的全部理论和实践立足点，更是党百年奋斗得出的历史结论。中国特色社会主义是党和人民历经千辛万苦、付出巨大代价取得的根本成就，是实现中华民族伟大复兴的正确道路。我们坚持和发展中国特色社会主义，推动物质文明、政治文明、精神文明、社会文明、生态文明协调发展，创造了中国式现代化新道路，创造了人类文明新形态。新的征程上，我们必须坚持党的基本理论、基本路线、基本方略，统筹推进“五位一体”总体布局、协调推进“四个全面”战略布局，全面深化改革开放，立足新发展阶段，完整、准确、全面贯彻新发展理念，构建新发展格局，推动高质量发展，推进科技自立自强，保证人民当家作主，坚持依法治国，坚持社会主义核心价值体系，坚持在发展中保障和改善民生，坚持人与自然和谐共生，协同推进人民富裕、国家强盛、中国美丽。<br>中华民族拥有在5000多年历史演进中形成的灿烂文明，中国共产党拥有百年奋斗实践和70多年执政兴国经验，我们积极学习借鉴人类文明的一切有益成果，欢迎一切有益的建议和善意的批评，但我们绝不接受“教师爷”般颐指气使的说教！中国共产党和中国人民将在自己选择的道路上昂首阔步走下去，把中国发展进步的命运牢牢掌握在自己手中！<br>——以史为鉴、开创未来，必须加快国防和军队现代化。强国必须强军，军强才能国安。坚持党指挥枪、建设自己的人民军队，是党在血与火的斗争中得出的颠扑不破的真理。人民军队为党和人民建立了不朽功勋，是保卫红色江山、维护民族尊严的坚强柱石，也是维护地区和世界和平的强大力量。<br>新的征程上，我们必须全面贯彻新时代党的强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，坚持走中国特色强军之路，全面推进政治建军、改革强军、科技强军、人才强军、依法治军，把人民军队建设成为世界一流军队，以更强大的能力、更可靠的手段捍卫国家主权、安全、发展利益！<br>——以史为鉴、开创未来，必须不断推动构建人类命运共同体。和平、和睦、和谐是中华民族5000多年来一直追求和传承的理念，中华民族的血液中没有侵略他人、称王称霸的基因。中国共产党关注人类前途命运，同世界上一切进步力量携手前进，中国始终是世界和平的建设者、全球发展的贡献者、国际秩序的维护者！<br>新的征程上，我们必须高举和平、发展、合作、共赢旗帜，奉行独立自主的和平外交政策，坚持走和平发展道路，推动建设新型国际关系，推动构建人类命运共同体，推动共建“一带一路”高质量发展，以中国的新发展为世界提供新机遇。中国共产党将继续同一切爱好和平的国家和人民一道，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持合作、不搞对抗，坚持开放、不搞封闭，坚持互利共赢、不搞零和博弈，反对霸权主义和强权政治，推动历史车轮向着光明的目标前进！<br>中国人民是崇尚正义、不畏强暴的人民，中华民族是具有强烈民族自豪感和自信心的民族。中国人民从来没有欺负、压迫、奴役过其他国家人民，过去没有，现在没有，将来也不会有。同时，中国人民也绝不允许任何外来势力欺负、压迫、奴役我们，谁妄想这样干，必将在14亿多中国人民用血肉筑成的钢铁长城面前碰得头破血流！<br>——以史为鉴、开创未来，必须进行具有许多新的历史特点的伟大斗争。敢于斗争、敢于胜利，是中国共产党不可战胜的强大精神力量。实现伟大梦想就要顽强拼搏、不懈奋斗。今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标，同时必须准备付出更为艰巨、更为艰苦的努力。<br>新的征程上，我们必须增强忧患意识、始终居安思危，贯彻总体国家安全观，统筹发展和安全，统筹中华民族伟大复兴战略全局和世界百年未有之大变局，深刻认识我国社会主要矛盾变化带来的新特征新要求，深刻认识错综复杂的国际环境带来的新矛盾新挑战，敢于斗争，善于斗争，逢山开道、遇水架桥，勇于战胜一切风险挑战！<br>——以史为鉴、开创未来，必须加强中华儿女大团结。在百年奋斗历程中，中国共产党始终把统一战线摆在重要位置，不断巩固和发展最广泛的统一战线，团结一切可以团结的力量、调动一切可以调动的积极因素，最大限度凝聚起共同奋斗的力量。爱国统一战线是中国共产党团结海内外全体中华儿女实现中华民族伟大复兴的重要法宝。<br>新的征程上，我们必须坚持大团结大联合，坚持一致性和多样性统一，加强思想政治引领，广泛凝聚共识，广聚天下英才，努力寻求最大公约数、画出最大同心圆，形成海内外全体中华儿女心往一处想、劲往一处使的生动局面，汇聚起实现民族复兴的磅礴力量！<br>——以史为鉴、开创未来，必须不断推进党的建设新的伟大工程。勇于自我革命是中国共产党区别于其他政党的显著标志。我们党历经千锤百炼而朝气蓬勃，一个很重要的原因就是我们始终坚持党要管党、全面从严治党，不断应对好自身在各个历史时期面临的风险考验，确保我们党在世界形势深刻变化的历史进程中始终走在时代前列，在应对国内外各种风险挑战的历史进程中始终成为全国人民的主心骨！<br>新的征程上，我们要牢记打铁必须自身硬的道理，增强全面从严治党永远在路上的政治自觉，以党的政治建设为统领，继续推进新时代党的建设新的伟大工程，不断严密党的组织体系，着力建设德才兼备的高素质干部队伍，坚定不移推进党风廉政建设和反腐败斗争，坚决清除一切损害党的先进性和纯洁性的因素，清除一切侵蚀党的健康肌体的病毒，确保党不变质、不变色、不变味，确保党在新时代坚持和发展中国特色社会主义的历史进程中始终成为坚强领导核心！<br>同志们、朋友们！<br>我们要全面准确贯彻“一国两制”、“港人治港”、“澳人治澳”、高度自治的方针，落实中央对香港、澳门特别行政区全面管治权，落实特别行政区维护国家安全的法律制度和执行机制，维护国家主权、安全、发展利益，维护特别行政区社会大局稳定，保持香港、澳门长期繁荣稳定。<br>解决台湾问题、实现祖国完全统一，是中国共产党矢志不渝的历史任务，是全体中华儿女的共同愿望。要坚持一个中国原则和“九二共识”，推进祖国和平统一进程。包括两岸同胞在内的所有中华儿女，要和衷共济、团结向前，坚决粉碎任何“台独”图谋，共创民族复兴美好未来。任何人都不要低估中国人民捍卫国家主权和领土完整的坚强决心、坚定意志、强大能力！<br>同志们、朋友们！<br>未来属于青年，希望寄予青年。一百年前，一群新青年高举马克思主义思想火炬，在风雨如晦的中国苦苦探寻民族复兴的前途。一百年来，在中国共产党的旗帜下，一代代中国青年把青春奋斗融入党和人民事业，成为实现中华民族伟大复兴的先锋力量。新时代的中国青年要以实现中华民族伟大复兴为己任，增强做中国人的志气、骨气、底气，不负时代，不负韶华，不负党和人民的殷切期望！<br>同志们、朋友们！<br>一百年前，中国共产党成立时只有50多名党员，今天已经成为拥有9500多万名党员、领导着14亿多人口大国、具有重大全球影响力的世界第一大执政党。<br>一百年前，中华民族呈现在世界面前的是一派衰败凋零的景象。今天，中华民族向世界展现的是一派欣欣向荣的气象，正以不可阻挡的步伐迈向伟大复兴。<br>过去一百年，中国共产党向人民、向历史交出了一份优异的答卷。现在，中国共产党团结带领中国人民又踏上了实现第二个百年奋斗目标新的赶考之路。<br>全体中国共产党员！党中央号召你们，牢记初心使命，坚定理想信念，践行党的宗旨，永远保持同人民群众的血肉联系，始终同人民想在一起、干在一起，风雨同舟、同甘共苦，继续为实现人民对美好生活的向往不懈努力，努力为党和人民争取更大光荣！<br>同志们、朋友们！<br>中国共产党立志于中华民族千秋伟业，百年恰是风华正茂！回首过去，展望未来，有中国共产党的坚强领导，有全国各族人民的紧密团结，全面建成社会主义现代化强国的目标一定能够实现，中华民族伟大复兴的中国梦一定能够实现！<br>伟大、光荣、正确的中国共产党万岁！<br>伟大、光荣、英雄的中国人民万岁！</p>]]></content>
      
      
      <categories>
          
          <category> 政治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研政治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第三章笔记</title>
      <link href="/2021/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2021/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第三章 栈和队列</h1><h2 id="复习时间轴">复习时间轴</h2><p><strong>6.28-29</strong>：看书复习、王道数据结构复习书相应部分并做题<br><strong>6.30</strong>：</p><ul><li>3.1.1 栈的定义和特点</li><li>3.1.2 栈的表示和操作实现</li><li>3.1.3 栈的应用：递归实现</li></ul><h2 id="知识框架">知识框架</h2><div class="mermaid">graph LR;    线性表--&gt;栈;线性表--&gt;队列;    线性表--&gt;数组;    栈--&gt;顺序栈;    栈--&gt;链栈;    栈--&gt;共享栈;    队列--&gt;循环队列;    队列--&gt;链式队列;    队列--&gt;双端队列;    数组--&gt;一维数组;    数组--&gt;多维数组;</div><h2 id="复习要点">复习要点</h2><ul><li>本章通常是考选择题，题目不难但是命题形式比较灵活，其中栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征是重点。由于它们是线性表的应用和推广，因此也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是必须掌握的内容。</li><li>线性表的应用以表的合并为重点，不仅要学会算法的实现，也要掌握合并算法复杂度的分析</li><li>递归是栈的最常见应用，结合算法实例理解</li></ul><h2 id="栈">栈</h2><ol><li>n个不同元素进栈，出栈元素不同排列的个数为卡特兰数：$\frac{1}{n+1}C_{2n}^{n}$</li><li>栈的基本操作</li></ol><h3 id="栈的顺序存储（顺序栈）">栈的顺序存储（顺序栈）</h3><p>采用顺序存储的栈叫做顺序栈，存储地址连续，设定top指针</p><ul><li>静态分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><ul><li>动态分配<br>因为栈在使用过程中所需最大空间的大小很难估计，因此一般来说，在初始化设定栈的时候不应该限定栈的最大容量，一个较合理的做法是：先分配一个初始容量，然后随着使用需要更多空间再重新分配。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype *base;</span><br><span class="line">    Elemtype *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>base叫做栈底指针，在顺序栈中，它始终指向栈底的位置，若base的值为NULL，则栈不存在（不代表栈为空），top为栈顶指针，初始化栈时会分配一个起始地址给top，并将base=top，即top=base为栈空条件</p><h3 id="栈的链式存储">栈的链式存储</h3><p>叫做链栈，优点是便于多个栈共享同一块存储空间和提高效率，不存在栈满上溢的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure><h3 id="栈的操作">栈的操作</h3><h4 id="初始化InitStack">初始化InitStack</h4><ul><li>静态分配<br>将top置为-1即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态分配<br>要分配空间，还要进行判断是否初始化成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(Elemtype*)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">    <span class="keyword">if</span>(S.base==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=InitSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈">进栈</h4><h4 id="出栈">出栈</h4><h4 id="判断栈空">判断栈空</h4><h4 id="读栈顶元素">读栈顶元素</h4><h3 id="共享栈">共享栈</h3><h3 id="栈的应用">栈的应用</h3><h4 id="数制转换">数制转换</h4><p>因为辗转相除法最后逆序正好符合了栈的LIFO的特点，所以可以用栈实现数制转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        S.Push(N%<span class="number">2</span>);</span><br><span class="line">        N=N/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">while</span>(!Empty(S))&#123;</span><br><span class="line">        S.pop(e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="括号匹配">括号匹配</h4><p>因为括号后面出现的右括号也是要先匹配前面最后一个左括号，也就是栈顶括号，也符合</p><h4 id="行编辑程序">行编辑程序</h4><p>用来设定输入缓冲区，根据栈顶是不是特殊字符判断什么操作</p><h4 id="迷宫求解">迷宫求解</h4><h4 id="表达式求值">表达式求值</h4><p>中缀表达式可以用符号栈和操作数栈分开</p><h3 id="函数调用栈">函数调用栈</h3><p>这个栈每个节点存储返回地址以及参数值</p><h3 id="栈与递归的实现">栈与递归的实现</h3><p>利用函数调用栈，在程序设计语言中实现递归。<br>**递归函数：**一个直接调用自己或者通过一系列调用语句间接调用自己的函数，叫做递归函数。<br>在一个函数的运行期间要调用其他函数的时候，系统需要做三件事</p><ul><li>将被调用的函数所需要的参数和执行完需要返回的地址传给被调用函数</li><li>分配存储空间给被调用函数存储局部变量</li><li>最后将控制权交给被调用函数<br>被调用函数执行完之后，保存计算结果，并释放局部变量的存储空间，返回到原先传给它的返回地址。<br>可以看出是后调用的函数先计算出结果，也就是先运行完，类似于栈的后进先出结构，所以使用函数调用栈来处理函数的调用问题。当一个函数执行完之后，就从栈顶弹出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组复习计划</title>
      <link href="/2021/06/29/%E8%AE%A1%E7%BB%84%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2021/06/29/%E8%AE%A1%E7%BB%84%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>总体规划</h1><ul><li>组成原理在计算机考研中非常重要，特别是针对 408 的考试，组成原理分值占 45 分，和数据结构并驾齐驱。在这门课程中，我们需要理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有计算机系统的整机概念。理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。这门课程是非记忆性的，侧重概念和原理的应用，各个章节之间也是紧密联系的，同学们要学会把所有的内容都串起来。</li><li>第一章计算机系统概述。这一章初步了解计算机执行的基本过程，这个过程贯彻到后面的各个章节，所以一定要理解透。</li><li>第二章数据的表示和运算。这一章主要有四部分内容，数制与编码、定点数的表示和运算、浮点数的表示和运算和算术逻辑单元 ALU，这一章内容比较零碎、也比较枯燥无聊，希望同学们多理解。</li><li>第三章存储器层次结构。这一章是重点章节，存储器的分类、存储器的层次结化结构、 半导体随机存取存储器主要考察概念。重点在主存储器与 CPU 的连接以及高速缓冲存储器两大块。另外，虚拟存储器有些自主命题的院校不考可以不看，408 命题喜欢将虚拟存储器和 OS 联合出题，同学们一定要重视。</li><li>第四章指令系统也是一大块考点，这一章通常会结合 CPU 系统进行考察。其中指令的寻址方式是重中之重。</li><li>第五章中央处理器是计算机的中心,也是本书的难点。其中,数据通路的分析、指令执行 阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特 点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。 但是针对不同学校第四章和第五章可能会有偏差，希望同学们参考院校大纲，有计划地进行 学习。</li><li>第六章总线的知识点较少，其中总线仲裁及总线操作和定时方式是难点。本章内容通常 以选择题的形式出现，特别是系统总线的特点、性能指标、各种仲裁方式的特点、异步定时 方式及常见的总线标准和特点等。总线带宽的计算也可能结合其他章节出综合题。</li><li>第七章结合操作系统《输入输出 I/O 管理》一起复习，磁盘存储、I/O 接口、中断以及 I/O 方式是本章节的重点。</li></ul><h1>复习要点</h1><p>六月到七月是复习计组的第一轮，复习方法偏重基础</p><ul><li>课本为主，在复习时勾画知识点，圈出重难点</li><li>看网课做好笔记，重点解决标注的重难点</li><li>课后练习有针对性做题（做好王道课后题就完事），多总结</li></ul><h1>复习进度</h1><div class="mermaid">gantt    title 计组复习进度    dateFormat YYYY-MM-DD    section 复习章节        第一章  :done, des1, 2021-06-29, 2021-06-30        第二章  :active, des2, 2021-06-30, 2021-07-01        第三章  :des3, 2021-07-01, 2021-07-02        第四章  :des4, 2021-07-02, 2021-07-08</div><ul><li>6.29 第一章计算机系统概述，看网课，王道计组复习书</li><li>6.30 看第一章课本，天勤网课</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研408 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组第一章笔记</title>
      <link href="/2021/06/29/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/06/29/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>复习要点</h1><p>本章是组成原理的概述，考察时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。重点在各个性能指标的计算，这部分考频很高。</p><ul><li>计算机由哪几部分组成？以哪部分为中心？</li><li>主频高的CPU一定比主频低的CPU快吗？为什么？</li><li>翻译程序、汇编程序、编译程序、解释程序有什么区别？各自的特性是什么？</li><li>不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</li></ul><h1>第一章 计算机系统概述</h1><p>三极管：高低电平控制导不导通，作为开关，表示计算机的0个1实现基本操作，实现与门、或门、异或门等<br>可以用来实现加法操作加减乘除都行</p><h2 id="计算机发展历程">计算机发展历程</h2><h3 id="计算机硬件的发展">计算机硬件的发展</h3><ol><li>ENIAC：1946第一台电子数字计算机，电子管时代（1946-1957）<br>特点：</li></ol><ul><li>逻辑元件采用电子管</li><li>使用机器语言进行编程</li><li>主存用延迟线或磁鼓存储信息，容量极小</li><li>体积庞大</li><li>运算速度较低，一般只有几千次到几万次每秒</li></ul><ol start="2"><li>第二代计算机：1958-1964，晶体管时代<br>特点：</li></ol><ul><li>逻辑元件采用晶体管</li><li>运算速度提高到几万次到几十万次</li></ul><h3 id="计算机软件的发展">计算机软件的发展</h3><p>比较次要，考的比较少</p><h2 id="计算机系统层次结构">计算机系统层次结构</h2><p>直接执行机器语言的机器成为实际机器M1：机器语言程序直接在M1上执行<br>具有将汇编语言程序翻译成机器语言程序的功能的机器M2：人们编写汇编语言程序向M2输入，而M2暗地里将汇编语言程序转换成机器语言程序交给M1去执行，所以M2实际上是一种程序，不是一种实际存在的机器，称为虚拟机<br>实际上汇编的每一条指令还是对应了一条机器语言语句，只是把奇奇怪怪的01串儿换成了人们好记住的英文单词add等，人们还是要熟悉机器语言的语句的作用跟这些语言是如何执行的，还是比较麻烦<br>所以20世纪60年代有了面向问题的高级语言，这种语言就不用去了解机器语言语句的作用了，程序员就只要理解一种高级语言的语法语义就完事儿了昂，用高级语言编写程序，然后有专门的编译程序给你整成汇编语言程序，然后由M2整成机器语言程序给M1，多了一层编译程序，但是方便了很多。这个编译程序给他起个名儿就叫高级语言机器M3，在这里根据高级语言的不同，这个机器可以是编译程序或者是解释程序。<br>编译程序：将一整个源程序全部编译优化成机器语言程序，然后再执行<br>解释程序：一句一句翻译成机器语言程序一句一句执行，搞一句就执行一句<br>机器语言机器M1还可以细分成微程序机器M0，把每一条机器语言指令换成一系列的微指令，然后每执行一条机器指令，就由M1指挥M0去执行相应的微程序，也就是说其实M0就跟M1没什么区别，就是将M1执行的指令换成微程序了。</p><ul><li>计组这门课主要讲M1跟M0，软件实现的就叫虚拟机，还有应用软件层在M3上面哈</li><li>在M1和M2之间存在着操作系统区分软件跟硬件，也就是操作系统当做桥梁架在软件（汇编程序）跟硬件（机器语言）之间。</li></ul><h3 id="区分计算机组成和计算机体系结构">区分计算机组成和计算机体系结构</h3><p>计算机体系结构就是那些能被程序员见到的计算机系统的属性，比如说指令集，数据类型，寻址技术，不同结构的计算机这些东西都是不同的，因为底层硬件就不一样。但是计算机组成就是在指令集的基础上讨论如何实现一种功能，比如说一台机器是否具备乘法指令，这就是结构方面的问题，但是如何实现乘法指令，这是一个组成问题，在一台硬件已经确定了的机器上如何发挥它的最大性能，这就是计算机组成所要解决的问题，采用不同的组成方式也就是不同的实现方式，可能会大幅度影响一台计算机的性能</p><h4 id="计算机软件和硬件的关系：">计算机软件和硬件的关系：</h4><ul><li>硬件和软件互相依存<br>硬件是软件工作的物质基础，软件的正常工作是硬件发挥作用的唯一途径</li><li>硬件和软件无严格界线<br>在许多情况下，计算机的某些功能既可以由硬件实现，也可以由软件来实现。因此，硬件与软件在一定意义上说没有严格的界线</li><li>硬件和软件协同发展<br>计算机软件随硬件技术的发展而发展，而软件的不断发展与完善又促进硬件的更新，两者交织发展，缺一不可</li></ul><h2 id="计算机的基本组成">计算机的基本组成</h2><h3 id="计算机硬件的基本组成">计算机硬件的基本组成</h3><p>冯诺依曼计算机是以运算器为中心的，而现代的计算机是以存储器为中心的。</p><h4 id="计算机的功能部件">计算机的功能部件</h4><ul><li>运算器</li><li>存储器</li><li>控制器</li><li>输入设备</li><li>输出设备</li></ul><h4 id="冯诺依曼计算机结构：">冯诺依曼计算机结构：</h4><ul><li>计算机由运算器、存储器、控制器、输入和输出设备五大部分组成</li><li>指令和数据以同等地为存放在存储器内，并可按地址寻访</li><li>指令和数据均采用二进制来表示</li><li>指令游操作码和地址码组成</li><li>指令在存储器内顺序存放。通常指顺序执行，在特定条件下，可根据运算结果或条件改变执行顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传输通过运算器完成</li></ul><h3 id="计算机系统的构成">计算机系统的构成</h3><p>存储器的工作方式是按存储单元的地址存取<br>MDR的长度等于存储单元的长度，称之为存储字长（字），即存储单元中存储基元的个数<br>存储字长可以是8位、16位、32位等，字节的二次幂的整数倍<br>每8个存储基元称之为一个字节，存储字长为字节的整数倍<br>位bit<br>字节byte<br>字word<br>MQ乘商寄存器<br>ACC累加器<br>ALU算术逻辑单元<br>X操作数寄存器<br>CU控制单元<br>IR指令寄存器：存放当前的指令<br>PC程序计数器：存放当前想要执行的指令的地址</p><h3 id="计算机的工作过程">计算机的工作过程</h3><ul><li>把程序和数据装入主存储器</li><li>将源程序转换为可执行文件</li><li>从可执行文件的首地址开始逐条执行指令</li></ul><ol><li>源程序到可执行文件<br>1）预处理：将#开头的命令处理了，比如说包含的头文件，加入到文件中，#define等等，输出一个.i文件就是包含所有需要执行的代码的程序<br>2）编译：将.i文件处理成汇编语言程序，输出.s文件<br>3）汇编：将.s翻译成机器语言程序，输出hello.o<br>4）链接：将多个可重定位目标文件和标准库函数合并为一个可执行目标文件。最终生成的可执行文件被保存在磁盘上。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研408 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/25/hello-world/"/>
      <url>/2021/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>写在前面</h1><p>最近一时兴起想要建个博客，用了Jerry的butterfly框架，平时记录一下笔记，以及一些脑子一热的想法。</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="测试一下mermaid插件">测试一下mermaid插件</h3><div class="mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</div><div class="mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 计组章节        Completed task            :done,    des1, 2014-01-06,2014-01-08        Active task               :active,  des2, 2014-01-09, 3d        Future task               :         des3, after des2, 5d        Future task2               :         des4, after des3, 5d        section Critical tasks        Completed task in the critical line :crit, done, 2014-01-06,24h        Implement parser and jison          :crit, done, after des1, 2d        Create tests for parser             :crit, active, 3d        Future task in critical line        :crit, 5d        Create tests for renderer           :2d        Add to mermaid                      :1d        section Documentation        Describe gantt syntax               :active, a1, after des1, 3d        Add gantt diagram to demo page      :after a1  , 20h        Add another diagram to demo page    :doc1, after a1  , 48h        section Last section        Describe gantt syntax               :after doc1, 3d        Add gantt diagram to demo page      : 20h        Add another diagram to demo page    : 48h</div><h3 id="测试一下公式">测试一下公式</h3><p>$$<br>\lim_{x\rightarrow 0}\left ( 1+x \right )^{\frac{1}{x}}=e<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第二章笔记</title>
      <link href="/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第二章 线性表</h1><div class="mermaid">graph TD;    线性表--&gt;顺序存储;线性表--&gt;链式存储;    链式存储--&gt;单链表;    链式存储--&gt;双链表;    链式存储--&gt;循环链表;    链式存储--&gt;静态链表;    单链表--&gt;指针实现;    双链表--&gt;指针实现;    循环链表--&gt;指针实现;</div><ul><li><p>线性表是算法题命题的重点。实现容易代码量少，但是同时也要求有最优的性能（时间复杂度和空间复杂度），才能拿满分。</p></li><li><p>考试中不要求代码有实际的可执行性，只要表达出算法的思想即可，不要死抠语法细节。</p></li><li><p>在考场上实在想不出来最优解可以采用暴力解也能拿至少一半分数。</p></li></ul><h2 id="线性表的类型定义">线性表的类型定义</h2><ol><li>线性结构特点：</li></ol><ul><li>存在唯一的一个被称作“第一个”的数据元素；</li><li>除第一个之外，集合中的每一个数据元素都只有一个前驱；</li><li>除了最后一个之外，集合中的每个数据元素都只有一个后继。</li></ul><ol start="2"><li><strong>线性表</strong>是最常用且最简单的一种数据结构。<br>线性表是有n个数据元素的有限序列，这里的数据元素可以是简单的int型整数，也可以是一个结构体，由若干个数据项组成，比如说链表，含有数据域以及指针域。<br>在这种情况下，数据元素可以叫做记录，含有大量记录的线性表叫做<strong>文件</strong>。</li><li>线性表特点</li></ol><ul><li>元素个数有限</li><li>表中元素具有先后次序</li><li>元素数据类型都相同</li><li>元素具有抽象性，仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容</li></ul><h2 id="线性表的顺序表示和实现">线性表的顺序表示和实现</h2><h3 id="顺序表定义">顺序表定义</h3><ol><li>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得在逻辑上相邻的两个元素在物理上也相邻。</li><li>顺序表的特点就是表中元素的逻辑顺序和物理顺序相同。</li><li><strong>位序</strong>：数组下标加一，即表示实际第几个元素（从一开始计数）</li><li>线性表顺序存储实现</li></ol><ul><li>静态分配（长度不可变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype data[MaxSize];<span class="comment">//顺序表元素</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;Sqlist;<span class="comment">//把struct换个名字</span></span><br></pre></td></tr></table></figure><ul><li>动态分配（长度可以变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype *data;</span><br><span class="line">  <span class="keyword">int</span> length, MaxSize;<span class="comment">//length：当前元素个数，MaxSize：数组最大长度（随着需要可以改变）</span></span><br><span class="line">&#125;Sqlist;</span><br><span class="line">L.data=(Elemtype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elemtype));<span class="comment">//C语言分配内存空间</span></span><br><span class="line">L.data=<span class="keyword">new</span> Elemtype[InitSize];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意C语言调用malloc函数要包含 <strong>#include&lt;stdlib.h&gt;</strong></p><ol start="5"><li>顺序表特点</li></ol><ul><li>最大特点是随机访问</li><li>存储密度高</li><li>插入删除要移动大量元素</li></ul><h3 id="顺序表基本操作实现">顺序表基本操作实现</h3><ol><li>插入操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(L.length&gt;=MaxSize)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/*注意这里判断插入位置i可以到length+1因为可以在这个位置插入（位序）</span></span><br><span class="line"><span class="comment">  而下面的移动元素数组的下标最多到length，此时数组里最后一个元素的下标是length-1</span></span><br><span class="line"><span class="comment">  因为要往后移动元素，所以要用到第length个数组位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=L.length;j&gt;=i;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j<span class="number">-1</span>];<span class="comment">//从第i个元素开始往后移动，这样数组里面L.data[i-1]就会空出来</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑时间复杂度为 $O(N)$。注意计算移动节点的平均次数。</p><ol start="2"><li>删除操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e=L.data[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&lt;L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j+<span class="number">1</span>];<span class="comment">//将第i个元素之后的元素前移</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意计算移动节点的平均次数。</p><ol start="3"><li>按值查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(Sqlist L, Elemtype e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意查找的平均比较次数。</p><h2 id="线性表的链式表示和实现">线性表的链式表示和实现</h2><p>显然，顺序表在插入删除方面有不可避免的缺点，所以链式存储应运而生，解决这个问题，但也失去了顺序存储的随机访问的优点。</p><p>线性表的链式存储也叫链表。</p><h3 id="单链表的定义">单链表的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  Elemtype data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*LinkList -&gt; LNode*</span></span><br><span class="line"><span class="comment">LinkList L;</span></span><br><span class="line"><span class="comment">LNode* L;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意这里的重命名，我们声明了一个叫做LNode的结构体，然后我们给他换个名字叫LNode，以及声明一个它的指针类型。</p><ol><li>头指针与头结点</li></ol><ul><li>头指针：指向链表第一个结点的指针，跟有没有头结点没有关系</li><li>头结点：有些定义为了方便操作，在第一个结点之前定义了一个叫做头结点的东西，该节点的指针指向第一个结点，头结点的数据域可以不存储东西，也可以存储比如说链表长度之类的东西</li></ul><ol start="2"><li>头结点的好处</li></ol><ul><li>第一个节点不用特殊处理（因为第一个节点跟其他节点一样，他的位置存放在上一个节点的next指针里，如果不使用头结点，那么第一个节点就要特殊处理，做题的时候注意审题），比如说在第一个结点前插入新节点或者说删除第一个结点我们都需要更改头指针的指向，非常麻烦。</li><li>非空表和空表的处理得到统一（因为无论是不是空表，头指针都是非空的），比如说一个不带头结点的空链表要插入一个结点，不带头结点的链表在第一个位置插入新节点，虽然都是在同一个位置插入，但是操作是不一样的，非常麻烦，容易出bug</li><li>总的来说就是没有头结点的时候，对于第一个结点的操作跟其他节点都是不一样的，每个操作都要考虑特殊情况，有头结点就没这么多鸟事</li></ul><ol start="3"><li>头插法建立单链表</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L-&gt;next;<span class="comment">//两步指针插入</span></span><br><span class="line">    L-&gt;next=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L;<span class="comment">//两步指针插入</span></span><br><span class="line">    L=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要创建头结点以及插入的时候先指向头指针所指向的节点（第一个结点），然后再将头指针指向新节点。</p><p>需要注意的是，头插法输入数据的顺序跟在链表中的顺序是相反的，可以用来将元素逆序。</p><ol start="4"><li>尾插法</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  LNode *s, *r=L;<span class="comment">//r为表尾指针</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    r-&gt;next=s;<span class="comment">//两步指针插入</span></span><br><span class="line">    r=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><p>思考</p><ol start="5"><li>按位查找</li><li>按值查找</li><li>插入结点</li><li>删除结点</li><li>求表长</li></ol><h3 id="双链表">双链表</h3><p>单链表有个缺点就是要找一个结点的前驱非常麻烦，要从头遍历，所以有了双链表，在结构体的指针域中增加一个指向前一个结点的指针，注意头结点的前驱指针指向空。</p><ol><li>插入</li><li>删除</li></ol><h3 id="循环链表">循环链表</h3><h4 id="循环单链表">循环单链表</h4><p>与单链表唯一的不同就是尾结点的next指针指向了头结点，变成了一个环。</p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研408 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
