<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Starry</title>
  
  <subtitle>always love you</subtitle>
  <link href="https://52hert-z.github.io/atom.xml" rel="self"/>
  
  <link href="https://52hert-z.github.io/"/>
  <updated>2021-07-05T14:03:18.992Z</updated>
  <id>https://52hert-z.github.io/</id>
  
  <author>
    <name>小澈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>🧠💫机器学习与数据挖掘期末复习（二）</title>
    <link href="https://52hert-z.github.io/2021/07/05/%E6%9C%BA%E5%99%A8/"/>
    <id>https://52hert-z.github.io/2021/07/05/%E6%9C%BA%E5%99%A8/</id>
    <published>2021-07-04T16:00:00.000Z</published>
    <updated>2021-07-05T14:03:18.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>1.深度学习和机器学习的区别</h1><p>机器学习是基于训练数据通过算法进行训练得到一个预测模型 用这个模型对无标签的数据进行预测 这就要求了在数据方面机器学习有较为严苛的要求 不好的数据会导致机器学习算法复杂度大大提高以及最后的结果的不理想<br>而深度学习则更像是人脑思考问题一般 先识别信息 之后进行处理 最后做出决策 这个模式也就说明了对于数据深度学习没有机器学习要求那么高 更多的是取决于神经网络采用了什么层</p><h1>2.监督学习和无监督学习的最主要区别</h1><p>监督学习是需要所有训练数据都带有标签 通过有标签数据去学习一个算法来对无标签数据进行预测<br>无监督学习是的训练数据都是无标签的 而是通过数据之间的联系来进行分类</p><h1>3.如何选择重要的特征</h1><ul><li>在选择重要特征前先去除特征集中有联系的那些特征</li><li>Lasso回归</li><li>随机森林可以知道哪些特征对预测有重要作用</li><li>基于信息增益的选择 也就是决策树</li></ul><h1>4.如何根据输入数据选择合适的机器学习算法</h1><ul><li>如果数据是线性的采用线性回归</li><li>如果非线性 bagging或者是核函数</li><li>如果对商业目标有一定要求 采用决策树或者SVM可能效果更好</li><li>如果数据是图像音频或者视频 神经网络会是一个好的选择</li></ul><h1>5.正则化在机器学习中的作用</h1><p>在预测函数中加入正则化项可以有效去除数据中的噪音和异常点 减少过拟合的概率</p><h1>6.高方差有用吗</h1><p>一般来说高方差是没有用的 说明数据的分布范围极大 特征的选择范围也很大 这对于计算跟处理来说都是一个很大的问题 所以我们都有归一化这样的操作就是说很多时候大范围的数据是起到反作用的 但有时也需要分布较广的数据</p><h1>7.如何处理高方差的数据</h1><p>如果一个数据集有较大的方差 我们可以用bagging的方法来进行不放回采样 从数据中挑选一个子集出来 子集通常会有更小的范围 而且我们基于这样的更好的数据子集产生了一组预测函数 采用投票式的方法决策出预测结果</p><h1>8.梯度下降以及随机梯度下降</h1><p>梯度下降是对所有样本进行梯度计算最后选择正确的梯度来进行下降 保证了最后肯定能收敛到全局最小<br>随机梯度下降只是随机处理一些样本而采用这些样本的梯度来最小化损失函数 不可能每一次都往正确方向下降 但是从整体方向还是会往全局最小迭代 最后的结果也往往在全局最小附近 好处就是计算量大大减小</p><h1>9.决策树的优点缺点</h1><p>优点：解释性强 具有更少的参数 对于异常点有更高的鲁棒性<br>缺点：如果数据中含有较多噪音 决策树容易过拟合</p><h1>10.混淆矩阵 作用</h1><p>混淆矩阵把预测正确和错误的个数进行了统计并放在一张表格里 可以非常直观地看到该模型在分类方面的性能 也让我们知道了模型在哪些地方犯错</p><h1>11.维度爆炸</h1><p>当数据集的具有很多特征的时候 很多特征其实就都是噪音 如果我们都去拟合的话 很容易就过拟合了<br>也就是说当数据集的维度大大超过我们实际需要维度的时候 这个维度空间里的大部分数据都是没有用的 我们平时使用的算法都将变得很低效</p><h1>12.正则化跟归一化区别</h1><p>正则化就是在预测函数后面加正则化项 使得预测函数有一定的伸缩性 可以容忍一些噪音对预测的影响 在防止过拟合方面有奇效<br>归一化是对数据集进行处理 将一个较大范围的数据映射到0，1区间里 可以看成是区间的伸缩变换</p><h1>13.归一化和标准化区别</h1><p>标准化是将数据分布化为标准正态分布 将平均值变为0 标准差变为1</p><h1>14.回归和分类的区别</h1><p>对于输出数据而言 回归输出的是代表数字意义的数字 而分类输出的是一种类别<br>回归是一种连续变量的预测<br>而分类是一种离散变量的预测</p><h1>15.什么是懒惰分类器</h1><p>KNN k近邻算法是懒惰分类器 因为它只是单纯的进行计算 而不会从数据集当中学到任何参数 也不会得出一个预测模型</p><h1>16.KMeans和KNN区别</h1><p>KNN是一种监督学习的算法 用有标签的数据来对无标签的数据进行预测 使用距离度量来选k个距离最近的邻居然后选择最多的那个分类作为预测结果<br>KMeans是一种无监督学习的算法 所有的数据都是无标签的 利用数据之间的联系将他们聚成一个一个的类</p><h1>17.SVM核函数</h1><p>当数据集线性不可分的时候 我们可以使用核函数将数据映射到高维空间使得数据线性可分</p><h1>18.集成学习模型 优点</h1><p>集成学习是采用一组预测函数来对同一样本进行预测 采用投票式算法选出最多的那个分类作为预测结果<br>优点是在单一分类器不太稳定的时候 多分类器可以保证预测的准确性 同时集成学习可以减少方差以及偏置 减少过拟合</p><h1>19.过拟合和欠拟合</h1><p>过拟合：模型对数据集中的噪音也考虑进去 使得模型过于复杂 导致模型在训练集的表现格外良好而在测试集表现很差的情况<br>欠拟合：模型太过简单 在训练集上就已经表现不佳</p><h1>20.Lasso和Ridge区别</h1><ul><li>Lasso是L1范数正则化项 是所有参数的绝对值之和</li><li>Ridge是L2范数 是所有参数的绝对值平方和<br>弹性网络是另外一种正则化的手段 将二者结合</li></ul><h1>21.概率和似然区别</h1><ul><li>概率是一个事情发生可能性的度量</li><li>似然函数（简称似然）是参数空间内参数的函数 描述获得观测数据的概率</li><li>基本的区别是概率跟可能的结果有关而似然是跟参数的假设有关</li></ul><h1>22.为什么剪枝</h1><p>因为决策树会将所有数据点都考虑进去导致决策树容易出现过拟合问题 为了解决决策树的过拟合问题 我们需要在处理到噪音的时候进行剪枝 去除这一部分数据点对整个模型的影响 如果一个新分支对于信息增益没有帮助那么果断剪枝 很有可能就是噪音</p><p>预剪枝以及后剪枝</p><h1>22.模型准确率和模型性能 哪个更好</h1><p>模型的性能衡量标准有很多 如果说模型的性能是指运行速度的话 那么这跟模型的使用算法构成底层有关 如果说是衡量分类表现的话 在不平衡的数据集里F1指标比准确率更能体现模型的性能 准确率并不是我们唯一追求的东西</p><h1>23.如何处理不平衡数据集</h1><ul><li>过采样：过采样就是将少数类的样本的规律提取出来采用该规律生成新的数据点使得多数类和少数类的数据规模相匹配 显然生成新数据可能会导致过拟合的问题</li><li>欠采样：欠采样就是随机删除多数类数据点 使得多数类跟少数类的数据规模相匹配 显然随机删除可能会删掉很多有用的信息</li></ul><h1>24.特征工程的重要性</h1><p>特征工程可以说是数据集的预处理 比如说特征选择、特征提取、特征生成、特征构造等等 使得我们将数据中对于我们预测有利的特征提取出去 去除掉无用的噪音或者是对我们预测没有好处的其他特征 生成最符合模型需要的 最符合约束的新数据集<br>比如说PCA主成分分析 将高维的数据映射到低维空间 保留了最有用的特征 去除了没用的特征以及噪音 大大降低了算法的复杂度 和过拟合的可能性<br>特征工程的两个主要目标：</p><ul><li>提高模型性能</li><li>生成符合模型约束需要的最适合的输入数据</li></ul><h1>25.Boosting和Bagging的区别</h1><ul><li>采样：Bagging采用的是有放回的采样 生成一组不同的独立的数据子集 而Boosting采用的是整个样本</li><li>权重：Bagging的所有样本的权重都是一样的 而Boosting会根据每一轮的预测结果的正误调整样本的权重 预测正确的会减少权重 预测错误的则增加</li><li>预测函数：Bagging的所有预测函数的权重都是一样的 最终决策结果每一个预测函数都贡献一样的力量 而Boosting的预测函数是有权重的 表现好的预测函数会获得更高的权重</li><li>并行：Bagging可以同时进行n个训练样本子集的生成以及n个预测函数的训练 这之间是互不干扰的 而Boosting只能顺序一轮一轮来 因为这一轮的样本权重跟函数权重需要上一轮的预测结果</li><li>作用：Bagging是用来减少数据集的方差也就是缩小数据集的取值范围因为是取数据子集 而Boosting主要是用各个弱分类器之间好而不同的特点进行优势互补以及克服它们的缺点</li></ul><h1>26.生成式和判别式方法</h1><ul><li>生成式方法：先给定一个联合概率分布 然后基于这个分布对数据集进行参数的预测</li><li>判别式方法：基于数据的条件分布 然后更改参数求出最合适的参数得出联合概率分布</li></ul><h1>27.超参数跟参数的区别</h1><p>超参数是在模型外部的参数 在开始训练之前人为设定初始值 在训练过程中也可以由训练结果自动更新<br>而参数是模型内部的 在训练过程中自动得到的 由训练集的数据得来</p><h1>28.如何确定聚类中类的个数</h1><p>通过轮廓系数的表现来确定类的个数取多少合适<br>轮廓系数取值-1到1 越接近1越好</p><h1>29.交叉验证的作用</h1><p>第一是在数据集比较小的时候 可以划分为k部分 用其中一部分作为测试集 依次轮流 可以使数据集得到充分利用<br>第二就是可以增加模型的准确性 确保每一部分样本都用于训练可以使模型更好的拟合</p><h1>30.KNN的距离度量</h1><ul><li>欧式距离</li><li>曼哈顿距离</li><li>闵可夫斯基距离</li><li>余弦距离</li><li>Jaccard距离</li></ul><h1>31.随机森林使用了什么集成学习技术</h1><p>随机森林使用了bagging 显然 随机森林每一棵树都是由bootstrap得来的数据子集再随机选择m个特征训练出来的预测函数 显然就是bagging</p><h1>32.信息增益和信息熵</h1><p>信息熵是代表信息量的大小 数据集越乱信息熵越大<br>信息增益是在按照属性分支前后的信息熵的差值</p><h1>33.使用SVM而不是用随机森林的场景</h1><ul><li>数据集线性不可分 我们需要用到SVM的核函数来进行高维映射 而不能用随机森林因为随机森林本质上还是决策树的集合 决策树没法处理线性不可分数据</li><li>高维空间 在高维空间SVM的表现比随机森林要好 可能是因为SVM提取的支持向量在计算上比较简单 而决策树需要计算所有的数据点</li></ul><h1>34.SVM会受异常点影响吗</h1><p>如果说C比较大 那么会受异常点的影响 其他情况下不会</p><h1>35.线性回归是否可以用核函数</h1><p>可以是可以 最好是不要 因为如果在线性回归应用核函数 复杂度将会比在SVM要高 线性回归是要到N立方的复杂度 SVM是N方k的复杂度 并且线性回归要计算所有的数据点 SVM只需要计算支持向量</p><h1>36.SVM是否能产生概率输出</h1><p>SVM的目标优化函数不包含概率因素 不会产生概率输出 可以转化成LR输出概率函数 比如说sklearn的一些参数可以让SVM输出概率结果 但底层也是转化为LR来输出 并不代表SVM可以输出概率</p><h1>37.贝叶斯风险和经验风险</h1><p>贝叶斯决策函数产生的风险就是贝叶斯风险 贝叶斯决策函数是我们能够得到的最好的决策函数 贝叶斯风险是对所有可能函数的风险的最小化<br>经验风险就是预测跟实际的差的函数再求和 对每一个样本都求一次损失函数再求和再求平均值 经验风险越小说明模型对样本的拟合程度越高</p><h1>38.拉格朗日乘子</h1><p>拉格朗日乘数法是在数学最优化里面寻找符合约束条件的局部最大值或者是局部最小值的方法<br>拉格朗日函数将目标函数和约束条件放在一起进行优化 将有约束难无解的问题转化为可求导的无约束问题<br>拉格朗日对偶函数使计算变得更加简单 同时得到一个最优解的下界</p><h1>39.随机森林的随机性体现在</h1><ul><li>bootstrap构建数据子集的时候是采用bagging的方法 随机放回采样</li><li>对任意一个数据子集都随机选择m个特征</li></ul><h1>40.随机森林为什么不容易过拟合</h1><p>如果说随机森林只有一棵树的话还是跟决策树是一样的 把数据都考虑进去容易过拟合<br>而多棵树的随机森林其实从采样上就已经是随机采样 只是考虑部分数据 减少了噪音的影响 并且我们是有多棵决策树共同决策的结果 同样减少了单棵决策树过拟合导致整体过拟合的可能</p><h1>41.深度学习模型和集成学习模型的联系</h1><p>深度学习模型里面采用了大量集成学习的方法 集成学习说到底就是一种群体智慧的体现 防止单个学习器不稳定而出错 比如说CNN Transformer</p><h1>42.集成学习的一组学习器不一定会比其中的单个学习器要准确</h1><p>因为集成学习采用的是一整组进行投票来决策出结果 实际上是选择了大多数决策器的共同结果 但是实际上每一个预测函数都只是对某一部分的数据有比较好的预测 但是如果说我们给定的测试集是对于一小部分数据 而这一小部分数据是随机森林里面大部分决策树没有训练到的 那么整体的预测结果就会出错 而那一小部分训练到的决策树的预测正确率就会比一整组的预测正确率要高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学校课程" scheme="https://52hert-z.github.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="机器学习" scheme="https://52hert-z.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="期末复习" scheme="https://52hert-z.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>🤔关于政治的一些思考（仅代表个人观点）</title>
    <link href="https://52hert-z.github.io/2021/07/01/%E6%94%BF%E6%B2%BB%E9%9A%8F%E6%83%B3/"/>
    <id>https://52hert-z.github.io/2021/07/01/%E6%94%BF%E6%B2%BB%E9%9A%8F%E6%83%B3/</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2021-07-01T12:00:36.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>考研过程中关于一些政治上的问题的自己的思考，仅代表我个人的观点，不保证正确，单纯记录下来自己的看法。🤥<br>不定期更新…<br>说的不对见谅…</p><hr><h3 id="什么叫做生产关系">什么叫做生产关系</h3><p>生产关系是人们在生产中形成的人和人之间的利益关系。包括三个方面：</p><ul><li>是所有制，这个东西归谁所有</li><li>是在生产当中，人和人之间的地位，是资本主义雇佣劳动的剥削关系，还是一起劳动的共生</li><li>是产品的分配关系，我们生产出来一些东西应该怎么分配，怎么样来分。是按劳分配还是按需分配，还是你拿大头我拿小头，我给你当苦力打工</li></ul><h3 id="怎么理解私人劳动和社会劳动的矛盾决定了商品经济的本质和发展过程">怎么理解私人劳动和社会劳动的矛盾决定了商品经济的本质和发展过程</h3><p>商品经济，也就是交换经济，不同于之前的自给自足，我们劳动为了生产出商品，想要卖给别人拿到货币再买东西。所以，决定我们是不是会被饿死的关键就是能不能把那些玩意儿卖出去，卖不卖的出去这个问题就是私人劳动能不能转化为社会劳动，也就是说我们的劳动是不是被社会承认，被承认了商品就卖出去了，就完事儿了。呃，在这里这个私人劳动在商品卖出去的同时也就转化为了社会劳动。<br>在这里显然私人劳动能不能转化为社会劳动这个矛盾就决定了我们的命运，也就是商品能不能卖出去。所以这就决定了商品经济的本质。<br>决定发展过程可以这么理解<br>在资本主义社会里，这个比较发达的商品经济中，基本矛盾依然是私人劳动和社会劳动，但是具体到这个阶段的话，就发展为生产资料私人占有和生产社会化之间的矛盾，但是决定生产者的仍然是这个商品能不能卖出去，只不过到资本主义里，买卖很容易，但是社会需求跟个人生产之间出现脱节，能卖出去多少成为了矛盾，这也就决定了商品经济的发展过程</p><h3 id="如何理解商品拜物教">如何理解商品拜物教</h3><p>这个感觉就是跟一种信奉一样，是人们在商品经济中的一种主观感受，人们无法卖出商品就没办法拿到钱，没有钱就没办法买东西。所以人们仿佛被商品扼住了命运的咽喉，被其决定了是生存还是裂开，商品仿佛像是神灵一般决定着人们的命运。因此，在商品经济中，有些人对待商品就好像对待神灵一样敬畏、崇拜，这就叫“商品拜物教”</p><h3 id="资本主义只通过剩余价值赚钱">资本主义只通过剩余价值赚钱</h3><p>比如说资本家花费钱购入原材料、生产家具的机器、厂房等等不变资本，然后花钱雇佣工人来生产家具，也就是可变资本，工人生产出家具被卖出去（精美的家具），我们可以知道精美的家具价格比较昂贵，原材料跟厂房那些成本也肯定比售价便宜很多，也就是实际上是工人劳动的价值给这件商品升值<br>首先资本家是会付给工人工钱的，但是实际上资本家付给工人的只是工人必要劳动的价值，工人还有剩余劳动是白给资本家打工的，比如说一天一百块，实际上工人打工10个小时就值100块，但是一天干了12个小时，这两个小时就是剩余劳动，就是白打工了，这部分劳动的价值给资本家剥削去了，资本家就是通过这一部分的价值赚到了钱</p><h3 id="如何理解共产主义按需分配导致生产发展停滞">如何理解共产主义按需分配导致生产发展停滞</h3><p>我们都知道共产主义是按需分配的，也就是我需要什么我就拿就完事了，那我成天在家好吃懒做不干活儿，社会生产力是不是就会止步不前，这种社会的状态肯定不是发展的终极状态，这是一种病态<br>实际上共产主义社会是建立在生产力极大发展，人民精神境界极大提高的基础之上，共产主义并不是生产力发展到很高程度就不生产了，而是人们已经具备了极高的思想觉悟，把劳动作为了生存的第一需求，每天就会自动自觉地投入到社会生产中去，而不像现在，劳动使人们谋生的手段。所以实际上到了共产主义社会，人人劳动的社会会极大促进生产力发展，并不会停滞<br>但是总感觉这好像乌托邦，太过理想化了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="政治" scheme="https://52hert-z.github.io/categories/%E6%94%BF%E6%B2%BB/"/>
    
    
    <category term="考研政治" scheme="https://52hert-z.github.io/tags/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>🧠💫机器学习与数据挖掘期末复习</title>
    <link href="https://52hert-z.github.io/2021/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%9C%9F%E6%9C%AB/"/>
    <id>https://52hert-z.github.io/2021/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%9C%9F%E6%9C%AB/</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2021-07-05T13:58:46.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>什么是机器学习</h1><p>机器学习包括几个关键词：计算机、经验/数据、模型、性能、预测<br>机器学习根据以往的经验和数据得到数学模型，并可以对未知数据进行预测，最终达到计算机算法和程序进行优化的目的</p><h2 id="基本术语">基本术语</h2><ul><li>泛化能力：机器学习的目标是让我们的模型能很好地应用于“新样本”，我们称模型适用于未知新样本的能力为泛化能力</li><li>监督学习：学习由一个输入到输出的映射，成为模型。模型的集合就是假设空间</li><li>半监督学习：具有少量标注数据，大量未标注数据，利用未标注数据的信息，辅助标注数据进行监督学习</li><li>主动学习：属于半监督学习的一种。先训练一个初始模型，给没有标签的数据打上伪标签，然后再用伪标签和其他有标签的数据重新训练模型。重复上述过程</li><li>模型评估和模型选择：<ul><li>训练误差：在训练过程中产生的误差</li><li>验证误差：在验证集上进行交叉验证选择参数（调参），最终模型在验证集上的误差就是验证误差。</li><li>测试误差：训练完毕、调参完毕的模型，在新的测试集上的误差，就是测试误差。</li><li>泛化误差：假如所有的数据来自一个整体，模型在这个整体上的误差，就是泛化误差。通常说来，测试误差的平均值或者说期望就是泛化误差。</li></ul></li></ul><p>综合来说，它们的大小关系为<br>训练误差 &lt; 验证误差 &lt; 测试误差 ～= 泛化误差</p><ul><li>损失函数：损失函数通常是针对单个训练样本而言，给定一个模型输出$\hat{y}$和一个真实输出$y$，损失函数衡量它们之间的差距，输出一个实值损失$L=f(y_{i},\hat{y}_{i})$</li><li>测试数据集准确度：</li></ul><h1>KNN（K近邻算法）</h1><ul><li>已有一批有标签的数据</li><li>输入没有标签的数据后，需要对他们进行分类。将新数据的每个特征和已有标签数据计算相似度</li><li>选取k个相似度最高的样本，分别统计他们的标签出现次数，出现最多的那个分类作为新数据的分类</li></ul><h2 id="如何定义相似度指标">如何定义相似度指标</h2><ol><li>直线距离（欧氏距离）</li><li>街区距离（曼哈顿距离）</li><li>闵可夫斯基距离：$\sum_{i=1}^{k}(\left | x_{i}-y_{i} \right |^{q})^{1-q}$</li><li>余弦距离</li></ol><h2 id="如何确定k值">如何确定k值</h2><ol><li>经验：对于n个训练样本，设置k为$\sqrt{n}$</li><li>实践中会通过交叉验证来确定k值<br>k折交叉验证：将数据集划分为k等分，一份为测试集，剩余的$k-1$份作为训练集，比如说第一次选取第一个$\frac{1}{k}$作为测试集，一直循环到最后一份，计算k次测试集上的正确率的平均值。</li></ol><h2 id="引入特征的重要性">引入特征的重要性</h2><p>计算相似度的时候将不同特征加权求和</p><h2 id="归一化">归一化</h2><p>不同特征指标单位不同，取值范围也不同，对距离的计算带来比较大的影响。使用minmax进行归一化，也就是将数据变成在区间$(0,1)$之间的小数。<br>$$<br>\frac{x-min(x)}{max(x)-min(x)}<br>$$</p><ul><li>主要是为了数据处理方便提出来的，把数据映射到0～1范围之内处理，更加便捷快速</li><li>把有量纲表达式变成无量纲表达式，便于不同单位或量级的指标能够进行比较和加权。<br>归一化是一种简化计算的方式，即将有量纲的表达式，经过变换，化为无量纲的表达式，成为纯量</li></ul><h2 id="标准化">标准化</h2><p>在机器学习中，我们可能要处理不同种类的资料，例如，音讯和图片上的像素值，这些资料可能是高维度的，资料标准化后会使每个特征中的数值平均变为0(将每个特征的值都减掉原始资料中该特征的平均)、标准差变为1，这个方法被广泛的使用在许多机器学习算法中(例如：支持向量机、逻辑回归和类神经网络)。</p><h2 id="中心化">中心化</h2><p>平均值为0，对标准差无要求</p><h2 id="归一化和标准化的区别">归一化和标准化的区别</h2><p>归一化是将样本的特征值转换到同一量纲下把数据映射到[0,1]或者[-1, 1]区间内，仅由变量的极值决定，因区间放缩法是归一化的一种。标准化是依照特征矩阵的列处理数据，其通过求z-score的方法，转换为标准正态分布，和整体样本分布相关，每个样本点都能对标准化产生影响。它们的相同点在于都能取消由于量纲不同引起的误差；都是一种线性变换，都是对向量X按照比例压缩再进行平移。</p><h2 id="标准化和中心化的区别">标准化和中心化的区别</h2><p>标准化是原始分数减去平均数然后除以标准差，中心化是原始分数减去平均数。 所以一般流程为先中心化再标准化。</p><h2 id="无量纲">无量纲</h2><p>我的理解就是通过某种方法能去掉实际过程中的单位，从而简化计算。</p><h2 id="KNN优点">KNN优点</h2><ol><li>很简单，容易实现</li><li>可以应用于任何分布的情况</li><li>样本数量很大也能产生好的结果</li></ol><h2 id="KNN缺点">KNN缺点</h2><ol><li>参数的选择，k值</li><li>对分类新的样本时间比较长，因为要计算大量的距离</li></ol><h1>决策树</h1><h2 id="CLS算法">CLS算法</h2><p>早期的决策树学习算法，是许多决策树学习算法的基础，他没有规定策略去选择属性</p><h2 id="ID3算法">ID3算法</h2><p>使用信息增益选择测试属性<br>$$<br>H(x)=-\sum p_{i}log(p_{i})<br>$$<br>$$<br>G(D,a)=H(D)-\sum_{v=1}^{V}\frac{|D^{v}|}{|D|}log_{2}\frac{|D^{v}|}{|D|}<br>$$<br>信息增益倾向于选择取值较多的特征，因此我们对信息增益归一化，引入增益率<br>也即是C4.5算法<br>$$<br>Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(D,a)}<br>$$<br>$$<br>IV(a)=-\sum_{v=1}^{V}\frac{|D^{v}|}{|D|}log_{2}\frac{|D^{v}|}{|D|}<br>$$<br>不过还存在的问题变成了倾向于取值数目比较少的属性<br>ID3算法的优点是：算法的理论清晰，方法简单，学习能力较强。其缺点是：只对比较小的数据集有效，且对噪声比较敏感，当训练数据集加大时，决策树可能会随之改变。</p><h2 id="启发式方法">启发式方法</h2><p>一种启发式方法是结合二者，先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</p><h2 id="CART算法">CART算法</h2><p>使用Gini指标进行属性选择<br>Gini值：反映了从D中随机抽取两个样本，其类别标记不一致的概率，<strong>因此Gini指标越小，代表这样分类的效果越好</strong><br>$$<br>Gini(D)=\sum_{k=1}^{|\gamma|}\sum_{k’\neq k}p_{k}p_{k’}=1-\sum_{k=1}^{|\gamma|}p_{k}^{2}<br>$$<br>$$<br>Gini_index(D,a)=\sum_{v=1}^{V}\frac{|D^{v}|}{|D|}Gini(D^{v})<br>$$<br>对于连续的问题，可以得到回归树：使用平方误差最小化作为衡量指标选择属性。对划分出来的样本集，计算他们的方差，目标是选取划分之后方差最小的划分方法。</p><h2 id="决策树过拟合问题">决策树过拟合问题</h2><p>先从数据集中划分出一部分验证集作为评估指标</p><ol><li>预剪枝：在模型构建过程中对模型进行剪枝<br>在决策树生成过程中，对每个节点在划分前进行验证集的估计，如果划分节点对泛化能力不带来提升，则停止划分并将当前节点记为叶节点</li><li>后剪枝：构建完之后再进行剪枝，方法是去掉每个节点，看能否带来泛化能力的提升，如果可以就去掉</li></ol><h2 id="连续值的处理">连续值的处理</h2><p>连续属性a在样本集中出现n个不同的取值，我们从小到大排列，对他们进行二分划分为两部分，划分的时候取中间值</p><h1>集成学习</h1><h2 id="bagging">bagging</h2><p>bagging是投票式算法，使用bootstrap产生训练集，从D中有放回抽样，分别基于这些训练数据集得到多个基础分类器，最后通过这些分类器得出模型，这些模型同时进行预测，选择得票最多的那个分类</p><h3 id="bagging的特点">bagging的特点</h3><ul><li>个体学习期之间不存在强依赖关系，具有独立性</li><li>可以并行生成</li><li>算法的复杂度低，训练一个bagging集成与直接使用基学习器的复杂度同阶</li></ul><h3 id="使用场景">使用场景</h3><p>单个模型不稳定，用集成的方法选择最适合的</p><h3 id="训练算法">训练算法</h3><p>通过对D有放回抽样，得到t个训练集$D_{t}$，使用$D_{t}$进行训练得到模型$M_{t}$。预测的时候使用组合分类器对样本进行分类，T个模型同时预测，并返回多数的表决</p><h2 id="随机森林">随机森林</h2><h3 id="随机森林的随机性">随机森林的随机性</h3><ol><li>对样本进行有放回的抽样</li><li>在对每个点划分的时候，随机选择特征进行考虑</li><li>样本在某个属性有多个特征值的时候，随机划分进一个特征值的分类中</li></ol><h3 id="算法">算法</h3><ol><li><p>用n来表示训练样本的个数，d表示特征数目</p></li><li><p>输入特征数目m，用于确定决策树划分属性个数，其中m应远小于d</p></li><li><p>从n个训练样本中以有放回抽样的方式，取样n次，形成一个训练集</p></li><li><p>对于每一个节点，随机选择m个特征，决策树上每个节点的决定都是基于这些特征确定的，根据这m个特征，计算其最佳的分裂方式</p></li><li><p>从数据集（表）中随机选择k个特征（列），共m个特征（其中k小于等于m）。然后根据这k个特征建立决策树。2. 重复n次，这k个特性经过不同随机组合建立起来n棵决策树（或者是数据的不同随机样本，称为自助法样本）。3. 对每个决策树都传递随机变量来预测结果。存储所有预测的结果（目标），你就可以从n棵决策树中得到n种结果。4. 计算每个预测目标的得票数再选择模式（最常见的目标变量）。换句话说，将得到高票数的预测目标作为随机森林算法的最终预测。</p></li></ol><p>优点：</p><ol><li>可以用来解决分类和回归问题：随机森林可以同时处理分类和数值特征。</li><li>抗过拟合能力：通过平均决策树，降低过拟合的风险性。决策树使用贪婪的思想，容易陷入局部最优，随机森林的随机性可以跳出局部最优。</li><li>只有在半数以上的基分类器出现差错时才会做出错误的预测：随机森林非常稳定，即使数据集中出现了一个新的数据点，整个算法也不会受到过多影响，它只会影响到一颗决策树，很难对所有决策树产生影响。</li><li>处理高维数据，不用进行特征选择</li><li>容易做成并行化方法<br>缺点：</li><li>据观测，如果一些分类/回归问题的训练数据中存在噪音，随机森林中的数据集会出现过拟合的现象。</li><li>比决策树算法更复杂，计算成本更高。</li><li>由于其本身的复杂性，它们比其他类似的算法需要更多的时间来训练。</li></ol><p>评价指标：分类间隔，对样本A有75%的分类正确，则分类间隔为75-25=50%<br>袋外错误率：对每⼀棵树来说，都有样本没有被抽样进⼊训练样本中，这些就是袋外样本。对袋外样本<br>预测的错误率就是袋外错误率。</p><h2 id="boosting">boosting</h2><p>Boosting是一种通过组合弱学习器来产生强学习器的通用且有效的方法。本文中我们将重点讲解三种Boosting算法:AdaBoost, RankBoost, Gradient Boosting。AdaBoost是第一个成功的Boosting算法,所以我们先介绍AdaBoost</p><h3 id="adaboost">adaboost</h3><p>AdaBoost解决了如下两个问题:首先,如何选择一组有不同优缺点的弱学习器,使得它们可以相互弥补不足。其次,如何组合弱学习器的输出以获得整体的更好的决策表现</p><p>我自己的理解：<br>adaboost对每个样本都维护一个权重分布，每个样本都有一个权重值表示它的重要性，在衡量错误率的时候，权重大的样本分类错误贡献了比权重小的更大的错误率。这使得弱分类器要聚焦于这些高权重的样本，引导这些弱学习器学习训练样本的不同部分，我们进行多轮训练，在每一轮训练中都更新权重分布，对那些误分类的样本提高权重，那些上一轮分类准确的就降低权重，这样每一轮弱学习器都有进步。<br>训练完之后，我们就得到了一组具有不同优缺点的弱学习器，给他们加权使它们的优势组合起来。</p><h3 id="bagging和boosting的区别">bagging和boosting的区别</h3><ol><li>样本选择：</li></ol><ul><li>bagging：训练集有放回抽样，从原始集中选出的各轮训练集是互相独立的</li><li>boosting：每一轮的训练集都一样只是样本在各个弱学习器中的权重发生变化</li></ul><ol start="2"><li>样例权重：</li></ol><ul><li>bagging：每个样本的权重相等</li><li>boosting：根据错误率不断调整样本的权重，聚焦于分类错的样本上</li></ul><ol start="3"><li>预测函数：</li></ol><ul><li>bagging：所有预测函数的权重相等</li><li>boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重</li></ul><ol start="4"><li>并行计算</li></ol><ul><li>bagging：各个预测函数可以并行生成</li><li>boosting：各个预测函数只能顺序生成，因为后一个模型的权重需要根据上一轮的分类结果</li></ul><h1>线性模型</h1><h2 id="线性判别分析LDA">线性判别分析LDA</h2><p>LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。</p><p>可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。<br><img src="/img/fx1.png" alt=""></p><h3 id="类内散度矩阵">类内散度矩阵</h3><p>衡量同一类内样本间的距离<br>$$<br>S_{w}=\sum_{0}+\sum_{1}=\sum_{x\in X_{0}}(x-\mu_{0})(x-\mu_{0})^{T}+\sum_{x\in X_{1}}(x-\mu_{1})(x-\mu_{1})^{T}<br>$$</p><h3 id="类间散度矩阵">类间散度矩阵</h3><p>衡量不同类之间的距离<br>$$<br>S_{b}=(\mu_{0}-\mu_{1})(\mu_{0}-\mu_{1})^{T}<br>$$</p><h3 id="最大化目标">最大化目标</h3><p>不同类别间距离最大，也就是投影后的样本他们的均值的方差最大</p><h2 id="多分类问题">多分类问题</h2><h1>支持向量机SVM</h1><p>⽀持向量机的⽬标，是找到⼀个超平⾯，能最好的分隔不同类别的样本。它的优化⽬标是：最⼤化样本<br>中距离超平⾯最近的距离，约束条件是样本都被正确分隔。也就是：<br><img src="/img/fx2.png" alt=""></p><h2 id="对偶问题">对偶问题</h2><p>通过拉格朗⽇乘⼦法将原始问题转化为对偶问题，通过解对偶问题得到原始问题的解。</p><h2 id="核函数">核函数</h2><hr><p>[随机森林][<a href="https://www.zhihu.com/question/64043740/answer/672248748">https://www.zhihu.com/question/64043740/answer/672248748</a>]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学校课程" scheme="https://52hert-z.github.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="机器学习" scheme="https://52hert-z.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="期末复习" scheme="https://52hert-z.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>英语生词✏️</title>
    <link href="https://52hert-z.github.io/2021/07/01/%E8%8B%B1%E8%AF%AD/"/>
    <id>https://52hert-z.github.io/2021/07/01/%E8%8B%B1%E8%AF%AD/</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2021-07-05T13:51:29.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>平时背单词遇到一些生词或是遗忘的纪录在此，没事过来看看</li></ul><h3 id="clash">clash</h3><ul><li>n. 冲突 差别 分歧</li><li>vi 打斗 冲突</li></ul><h3 id="arithmetic">arithmetic</h3><ul><li>n 算术 算术运算</li></ul><h3 id="associate">associate</h3><ul><li>vt 联想联系</li><li>n 同事 伙伴</li><li>adj 副的<ul><li>I’m an associate producer at “New Night”.</li><li>我是《晚间新闻》的副制片人</li></ul></li></ul><h3 id="badminton">badminton</h3><ul><li>n 羽毛球运动</li></ul><h3 id="balcony">balcony</h3><ul><li>n 阳台 （剧院的）楼座</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="业务课" scheme="https://52hert-z.github.io/categories/%E4%B8%9A%E5%8A%A1%E8%AF%BE/"/>
    
    
    <category term="考研英语" scheme="https://52hert-z.github.io/tags/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>习总书记建党100周年讲话🎉🎉</title>
    <link href="https://52hert-z.github.io/2021/07/01/%E5%BA%86%E7%A5%9D%E5%BB%BA%E5%85%9A/"/>
    <id>https://52hert-z.github.io/2021/07/01/%E5%BA%86%E7%A5%9D%E5%BB%BA%E5%85%9A/</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2021-07-01T12:00:09.354Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/peitu2.jpg" alt="avatar"></p><h1>习近平：在庆祝中国共产党成立一百周年大会上的讲话</h1><p>同志们，朋友们：<br>今天，在中国共产党历史上，在中华民族历史上，都是一个十分重大而庄严的日子。我们在这里隆重集会，同全党全国各族人民一道，庆祝中国共产党成立一百周年，回顾中国共产党百年奋斗的光辉历程，展望中华民族伟大复兴的光明前景。<br>首先，我代表党中央，向全体中国共产党员致以节日的热烈祝贺！<br>在这里，我代表党和人民庄严宣告，经过全党全国各族人民持续奋斗，我们实现了第一个百年奋斗目标，在中华大地上全面建成了小康社会，历史性地解决了绝对贫困问题，正在意气风发向着全面建成社会主义现代化强国的第二个百年奋斗目标迈进。这是中华民族的伟大光荣！这是中国人民的伟大光荣！这是中国共产党的伟大光荣！<br>同志们、朋友们！<br>中华民族是世界上伟大的民族，有着5000多年源远流长的文明历史，为人类文明进步作出了不可磨灭的贡献。1840年鸦片战争以后，中国逐步成为半殖民地半封建社会，国家蒙辱、人民蒙难、文明蒙尘，中华民族遭受了前所未有的劫难。从那时起，实现中华民族伟大复兴，就成为中国人民和中华民族最伟大的梦想。<br>为了拯救民族危亡，中国人民奋起反抗，仁人志士奔走呐喊，太平天国运动、戊戌变法、义和团运动、辛亥革命接连而起，各种救国方案轮番出台，但都以失败而告终。中国迫切需要新的思想引领救亡运动，迫切需要新的组织凝聚革命力量。<br>十月革命一声炮响，给中国送来了马克思列宁主义。在中国人民和中华民族的伟大觉醒中，在马克思列宁主义同中国工人运动的紧密结合中，中国共产党应运而生。中国产生了共产党，这是开天辟地的大事变，深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局。<br>中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心使命。一百年来，中国共产党团结带领中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题：实现中华民族伟大复兴。<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，浴血奋战、百折不挠，创造了新民主主义革命的伟大成就。我们经过北伐战争、土地革命战争、抗日战争、解放战争，以武装的革命反对武装的反革命，推翻帝国主义、封建主义、官僚资本主义三座大山，建立了人民当家作主的中华人民共和国，实现了民族独立、人民解放。新民主主义革命的胜利，彻底结束了旧中国半殖民地半封建社会的历史，彻底结束了旧中国一盘散沙的局面，彻底废除了列强强加给中国的不平等条约和帝国主义在中国的一切特权，为实现中华民族伟大复兴创造了根本社会条件。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，中国人民站起来了，中华民族任人宰割、饱受欺凌的时代一去不复返了！<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，自力更生、发愤图强，创造了社会主义革命和建设的伟大成就。我们进行社会主义革命，消灭在中国延续几千年的封建剥削压迫制度，确立社会主义基本制度，推进社会主义建设，战胜帝国主义、霸权主义的颠覆破坏和武装挑衅，实现了中华民族有史以来最为广泛而深刻的社会变革，实现了一穷二白、人口众多的东方大国大步迈进社会主义社会的伟大飞跃，为实现中华民族伟大复兴奠定了根本政治前提和制度基础。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，中国人民不但善于破坏一个旧世界、也善于建设一个新世界，只有社会主义才能救中国，只有社会主义才能发展中国！<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，解放思想、锐意进取，创造了改革开放和社会主义现代化建设的伟大成就。我们实现新中国成立以来党的历史上具有深远意义的伟大转折，确立党在社会主义初级阶段的基本路线，坚定不移推进改革开放，战胜来自各方面的风险挑战，开创、坚持、捍卫、发展中国特色社会主义，实现了从高度集中的计划经济体制到充满活力的社会主义市场经济体制、从封闭半封闭到全方位开放的历史性转变，实现了从生产力相对落后的状况到经济总量跃居世界第二的历史性突破，实现了人民生活从温饱不足到总体小康、奔向全面小康的历史性跨越，为实现中华民族伟大复兴提供了充满新的活力的体制保证和快速发展的物质条件。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，改革开放是决定当代中国前途命运的关键一招，中国大踏步赶上了时代！<br>——为了实现中华民族伟大复兴，中国共产党团结带领中国人民，自信自强、守正创新，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，创造了新时代中国特色社会主义的伟大成就。党的十八大以来，中国特色社会主义进入新时代，我们坚持和加强党的全面领导，统筹推进“五位一体”总体布局、协调推进“四个全面”战略布局，坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化，坚持依规治党、形成比较完善的党内法规体系，战胜一系列重大风险挑战，实现第一个百年奋斗目标，明确实现第二个百年奋斗目标的战略安排，党和国家事业取得历史性成就、发生历史性变革，为实现中华民族伟大复兴提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，中华民族迎来了从站起来、富起来到强起来的伟大飞跃，实现中华民族伟大复兴进入了不可逆转的历史进程！<br>一百年来，中国共产党团结带领中国人民，以“为有牺牲多壮志，敢教日月换新天”的大无畏气概，书写了中华民族几千年历史上最恢宏的史诗。这一百年来开辟的伟大道路、创造的伟大事业、取得的伟大成就，必将载入中华民族发展史册、人类文明发展史册！<br>同志们、朋友们！<br>一百年前，中国共产党的先驱们创建了中国共产党，形成了坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，这是中国共产党的精神之源。<br>一百年来，中国共产党弘扬伟大建党精神，在长期奋斗中构建起中国共产党人的精神谱系，锤炼出鲜明的政治品格。历史川流不息，精神代代相传。我们要继续弘扬光荣传统、赓续红色血脉，永远把伟大建党精神继承下去、发扬光大！<br>同志们、朋友们！<br>一百年来，我们取得的一切成就，是中国共产党人、中国人民、中华民族团结奋斗的结果。以毛泽东同志、邓小平同志、江泽民同志、胡锦涛同志为主要代表的中国共产党人，为中华民族伟大复兴建立了彪炳史册的伟大功勋！我们向他们表示崇高的敬意！<br>此时此刻，我们深切怀念为中国革命、建设、改革，为中国共产党建立、巩固、发展作出重大贡献的毛泽东、周恩来、刘少奇、朱德、邓小平、陈云同志等老一辈革命家，深切怀念为建立、捍卫、建设新中国英勇牺牲的革命先烈，深切怀念为改革开放和社会主义现代化建设英勇献身的革命烈士，深切怀念近代以来为民族独立和人民解放顽强奋斗的所有仁人志士。他们为祖国和民族建立的丰功伟绩永载史册！他们的崇高精神永远铭记在人民心中！<br>人民是历史的创造者，是真正的英雄。我代表党中央，向全国广大工人、农民、知识分子，向各民主党派和无党派人士、各人民团体、各界爱国人士，向人民解放军指战员、武警部队官兵、公安干警和消防救援队伍指战员，向全体社会主义劳动者，向统一战线广大成员，致以崇高的敬意！向香港特别行政区同胞、澳门特别行政区同胞和台湾同胞以及广大侨胞，致以诚挚的问候！向一切同中国人民友好相处，关心和支持中国革命、建设、改革事业的各国人民和朋友，致以衷心的谢意！<br>同志们、朋友们！<br>初心易得，始终难守。以史为鉴，可以知兴替。我们要用历史映照现实、远观未来，从中国共产党的百年奋斗中看清楚过去我们为什么能够成功、弄明白未来我们怎样才能继续成功，从而在新的征程上更加坚定、更加自觉地牢记初心使命、开创美好未来。<br>——以史为鉴、开创未来，必须坚持中国共产党坚强领导。办好中国的事情，关键在党。中华民族近代以来180多年的历史、中国共产党成立以来100年的历史、中华人民共和国成立以来70多年的历史都充分证明，没有中国共产党，就没有新中国，就没有中华民族伟大复兴。历史和人民选择了中国共产党。中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，是党和国家的根本所在、命脉所在，是全国各族人民的利益所系、命运所系。<br>新的征程上，我们必须坚持党的全面领导，不断完善党的领导，增强“四个意识”、坚定“四个自信”、做到“两个维护”，牢记“国之大者”，不断提高党科学执政、民主执政、依法执政水平，充分发挥党总揽全局、协调各方的领导核心作用！<br>——以史为鉴、开创未来，必须团结带领中国人民不断为美好生活而奋斗。江山就是人民、人民就是江山，打江山、守江山，守的是人民的心。中国共产党根基在人民、血脉在人民、力量在人民。中国共产党始终代表最广大人民根本利益，与人民休戚与共、生死相依，没有任何自己特殊的利益，从来不代表任何利益集团、任何权势团体、任何特权阶层的利益。任何想把中国共产党同中国人民分割开来、对立起来的企图，都是绝不会得逞的！9500多万中国共产党人不答应！14亿多中国人民也不答应！<br>新的征程上，我们必须紧紧依靠人民创造历史，坚持全心全意为人民服务的根本宗旨，站稳人民立场，贯彻党的群众路线，尊重人民首创精神，践行以人民为中心的发展思想，发展全过程人民民主，维护社会公平正义，着力解决发展不平衡不充分问题和人民群众急难愁盼问题，推动人的全面发展、全体人民共同富裕取得更为明显的实质性进展！<br>——以史为鉴、开创未来，必须继续推进马克思主义中国化。马克思主义是我们立党立国的根本指导思想，是我们党的灵魂和旗帜。中国共产党坚持马克思主义基本原理，坚持实事求是，从中国实际出发，洞察时代大势，把握历史主动，进行艰辛探索，不断推进马克思主义中国化时代化，指导中国人民不断推进伟大社会革命。中国共产党为什么能，中国特色社会主义为什么好，归根到底是因为马克思主义行！<br>新的征程上，我们必须坚持马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观，全面贯彻新时代中国特色社会主义思想，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，用马克思主义观察时代、把握时代、引领时代，继续发展当代中国马克思主义、21世纪马克思主义！ ——以史为鉴、开创未来，必须坚持和发展中国特色社会主义。走自己的路，是党的全部理论和实践立足点，更是党百年奋斗得出的历史结论。中国特色社会主义是党和人民历经千辛万苦、付出巨大代价取得的根本成就，是实现中华民族伟大复兴的正确道路。我们坚持和发展中国特色社会主义，推动物质文明、政治文明、精神文明、社会文明、生态文明协调发展，创造了中国式现代化新道路，创造了人类文明新形态。新的征程上，我们必须坚持党的基本理论、基本路线、基本方略，统筹推进“五位一体”总体布局、协调推进“四个全面”战略布局，全面深化改革开放，立足新发展阶段，完整、准确、全面贯彻新发展理念，构建新发展格局，推动高质量发展，推进科技自立自强，保证人民当家作主，坚持依法治国，坚持社会主义核心价值体系，坚持在发展中保障和改善民生，坚持人与自然和谐共生，协同推进人民富裕、国家强盛、中国美丽。<br>中华民族拥有在5000多年历史演进中形成的灿烂文明，中国共产党拥有百年奋斗实践和70多年执政兴国经验，我们积极学习借鉴人类文明的一切有益成果，欢迎一切有益的建议和善意的批评，但我们绝不接受“教师爷”般颐指气使的说教！中国共产党和中国人民将在自己选择的道路上昂首阔步走下去，把中国发展进步的命运牢牢掌握在自己手中！<br>——以史为鉴、开创未来，必须加快国防和军队现代化。强国必须强军，军强才能国安。坚持党指挥枪、建设自己的人民军队，是党在血与火的斗争中得出的颠扑不破的真理。人民军队为党和人民建立了不朽功勋，是保卫红色江山、维护民族尊严的坚强柱石，也是维护地区和世界和平的强大力量。<br>新的征程上，我们必须全面贯彻新时代党的强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，坚持走中国特色强军之路，全面推进政治建军、改革强军、科技强军、人才强军、依法治军，把人民军队建设成为世界一流军队，以更强大的能力、更可靠的手段捍卫国家主权、安全、发展利益！<br>——以史为鉴、开创未来，必须不断推动构建人类命运共同体。和平、和睦、和谐是中华民族5000多年来一直追求和传承的理念，中华民族的血液中没有侵略他人、称王称霸的基因。中国共产党关注人类前途命运，同世界上一切进步力量携手前进，中国始终是世界和平的建设者、全球发展的贡献者、国际秩序的维护者！<br>新的征程上，我们必须高举和平、发展、合作、共赢旗帜，奉行独立自主的和平外交政策，坚持走和平发展道路，推动建设新型国际关系，推动构建人类命运共同体，推动共建“一带一路”高质量发展，以中国的新发展为世界提供新机遇。中国共产党将继续同一切爱好和平的国家和人民一道，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持合作、不搞对抗，坚持开放、不搞封闭，坚持互利共赢、不搞零和博弈，反对霸权主义和强权政治，推动历史车轮向着光明的目标前进！<br>中国人民是崇尚正义、不畏强暴的人民，中华民族是具有强烈民族自豪感和自信心的民族。中国人民从来没有欺负、压迫、奴役过其他国家人民，过去没有，现在没有，将来也不会有。同时，中国人民也绝不允许任何外来势力欺负、压迫、奴役我们，谁妄想这样干，必将在14亿多中国人民用血肉筑成的钢铁长城面前碰得头破血流！<br>——以史为鉴、开创未来，必须进行具有许多新的历史特点的伟大斗争。敢于斗争、敢于胜利，是中国共产党不可战胜的强大精神力量。实现伟大梦想就要顽强拼搏、不懈奋斗。今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标，同时必须准备付出更为艰巨、更为艰苦的努力。<br>新的征程上，我们必须增强忧患意识、始终居安思危，贯彻总体国家安全观，统筹发展和安全，统筹中华民族伟大复兴战略全局和世界百年未有之大变局，深刻认识我国社会主要矛盾变化带来的新特征新要求，深刻认识错综复杂的国际环境带来的新矛盾新挑战，敢于斗争，善于斗争，逢山开道、遇水架桥，勇于战胜一切风险挑战！<br>——以史为鉴、开创未来，必须加强中华儿女大团结。在百年奋斗历程中，中国共产党始终把统一战线摆在重要位置，不断巩固和发展最广泛的统一战线，团结一切可以团结的力量、调动一切可以调动的积极因素，最大限度凝聚起共同奋斗的力量。爱国统一战线是中国共产党团结海内外全体中华儿女实现中华民族伟大复兴的重要法宝。<br>新的征程上，我们必须坚持大团结大联合，坚持一致性和多样性统一，加强思想政治引领，广泛凝聚共识，广聚天下英才，努力寻求最大公约数、画出最大同心圆，形成海内外全体中华儿女心往一处想、劲往一处使的生动局面，汇聚起实现民族复兴的磅礴力量！<br>——以史为鉴、开创未来，必须不断推进党的建设新的伟大工程。勇于自我革命是中国共产党区别于其他政党的显著标志。我们党历经千锤百炼而朝气蓬勃，一个很重要的原因就是我们始终坚持党要管党、全面从严治党，不断应对好自身在各个历史时期面临的风险考验，确保我们党在世界形势深刻变化的历史进程中始终走在时代前列，在应对国内外各种风险挑战的历史进程中始终成为全国人民的主心骨！<br>新的征程上，我们要牢记打铁必须自身硬的道理，增强全面从严治党永远在路上的政治自觉，以党的政治建设为统领，继续推进新时代党的建设新的伟大工程，不断严密党的组织体系，着力建设德才兼备的高素质干部队伍，坚定不移推进党风廉政建设和反腐败斗争，坚决清除一切损害党的先进性和纯洁性的因素，清除一切侵蚀党的健康肌体的病毒，确保党不变质、不变色、不变味，确保党在新时代坚持和发展中国特色社会主义的历史进程中始终成为坚强领导核心！<br>同志们、朋友们！<br>我们要全面准确贯彻“一国两制”、“港人治港”、“澳人治澳”、高度自治的方针，落实中央对香港、澳门特别行政区全面管治权，落实特别行政区维护国家安全的法律制度和执行机制，维护国家主权、安全、发展利益，维护特别行政区社会大局稳定，保持香港、澳门长期繁荣稳定。<br>解决台湾问题、实现祖国完全统一，是中国共产党矢志不渝的历史任务，是全体中华儿女的共同愿望。要坚持一个中国原则和“九二共识”，推进祖国和平统一进程。包括两岸同胞在内的所有中华儿女，要和衷共济、团结向前，坚决粉碎任何“台独”图谋，共创民族复兴美好未来。任何人都不要低估中国人民捍卫国家主权和领土完整的坚强决心、坚定意志、强大能力！<br>同志们、朋友们！<br>未来属于青年，希望寄予青年。一百年前，一群新青年高举马克思主义思想火炬，在风雨如晦的中国苦苦探寻民族复兴的前途。一百年来，在中国共产党的旗帜下，一代代中国青年把青春奋斗融入党和人民事业，成为实现中华民族伟大复兴的先锋力量。新时代的中国青年要以实现中华民族伟大复兴为己任，增强做中国人的志气、骨气、底气，不负时代，不负韶华，不负党和人民的殷切期望！<br>同志们、朋友们！<br>一百年前，中国共产党成立时只有50多名党员，今天已经成为拥有9500多万名党员、领导着14亿多人口大国、具有重大全球影响力的世界第一大执政党。<br>一百年前，中华民族呈现在世界面前的是一派衰败凋零的景象。今天，中华民族向世界展现的是一派欣欣向荣的气象，正以不可阻挡的步伐迈向伟大复兴。<br>过去一百年，中国共产党向人民、向历史交出了一份优异的答卷。现在，中国共产党团结带领中国人民又踏上了实现第二个百年奋斗目标新的赶考之路。<br>全体中国共产党员！党中央号召你们，牢记初心使命，坚定理想信念，践行党的宗旨，永远保持同人民群众的血肉联系，始终同人民想在一起、干在一起，风雨同舟、同甘共苦，继续为实现人民对美好生活的向往不懈努力，努力为党和人民争取更大光荣！<br>同志们、朋友们！<br>中国共产党立志于中华民族千秋伟业，百年恰是风华正茂！回首过去，展望未来，有中国共产党的坚强领导，有全国各族人民的紧密团结，全面建成社会主义现代化强国的目标一定能够实现，中华民族伟大复兴的中国梦一定能够实现！<br>伟大、光荣、正确的中国共产党万岁！<br>伟大、光荣、英雄的中国人民万岁！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="政治" scheme="https://52hert-z.github.io/categories/%E6%94%BF%E6%B2%BB/"/>
    
    
    <category term="考研政治" scheme="https://52hert-z.github.io/tags/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第三章笔记</title>
    <link href="https://52hert-z.github.io/2021/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://52hert-z.github.io/2021/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</id>
    <published>2021-06-28T16:00:00.000Z</published>
    <updated>2021-06-30T13:36:27.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第三章 栈和队列</h1><h2 id="复习时间轴">复习时间轴</h2><p><strong>6.28-29</strong>：看书复习、王道数据结构复习书相应部分并做题<br><strong>6.30</strong>：</p><ul><li>3.1.1 栈的定义和特点</li><li>3.1.2 栈的表示和操作实现</li><li>3.1.3 栈的应用：递归实现</li></ul><h2 id="知识框架">知识框架</h2><div class="mermaid">graph LR;    线性表--&gt;栈;线性表--&gt;队列;    线性表--&gt;数组;    栈--&gt;顺序栈;    栈--&gt;链栈;    栈--&gt;共享栈;    队列--&gt;循环队列;    队列--&gt;链式队列;    队列--&gt;双端队列;    数组--&gt;一维数组;    数组--&gt;多维数组;</div><h2 id="复习要点">复习要点</h2><ul><li>本章通常是考选择题，题目不难但是命题形式比较灵活，其中栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征是重点。由于它们是线性表的应用和推广，因此也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是必须掌握的内容。</li><li>线性表的应用以表的合并为重点，不仅要学会算法的实现，也要掌握合并算法复杂度的分析</li><li>递归是栈的最常见应用，结合算法实例理解</li></ul><h2 id="栈">栈</h2><ol><li>n个不同元素进栈，出栈元素不同排列的个数为卡特兰数：$\frac{1}{n+1}C_{2n}^{n}$</li><li>栈的基本操作</li></ol><h3 id="栈的顺序存储（顺序栈）">栈的顺序存储（顺序栈）</h3><p>采用顺序存储的栈叫做顺序栈，存储地址连续，设定top指针</p><ul><li>静态分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><ul><li>动态分配<br>因为栈在使用过程中所需最大空间的大小很难估计，因此一般来说，在初始化设定栈的时候不应该限定栈的最大容量，一个较合理的做法是：先分配一个初始容量，然后随着使用需要更多空间再重新分配。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype *base;</span><br><span class="line">    Elemtype *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>base叫做栈底指针，在顺序栈中，它始终指向栈底的位置，若base的值为NULL，则栈不存在（不代表栈为空），top为栈顶指针，初始化栈时会分配一个起始地址给top，并将base=top，即top=base为栈空条件</p><h3 id="栈的链式存储">栈的链式存储</h3><p>叫做链栈，优点是便于多个栈共享同一块存储空间和提高效率，不存在栈满上溢的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure><h3 id="栈的操作">栈的操作</h3><h4 id="初始化InitStack">初始化InitStack</h4><ul><li>静态分配<br>将top置为-1即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态分配<br>要分配空间，还要进行判断是否初始化成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base=(Elemtype*)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(Elemtype));</span><br><span class="line">    <span class="keyword">if</span>(S.base==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top=S.base;</span><br><span class="line">    S.stacksize=InitSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈">进栈</h4><h4 id="出栈">出栈</h4><h4 id="判断栈空">判断栈空</h4><h4 id="读栈顶元素">读栈顶元素</h4><h3 id="共享栈">共享栈</h3><h3 id="栈的应用">栈的应用</h3><h4 id="数制转换">数制转换</h4><p>因为辗转相除法最后逆序正好符合了栈的LIFO的特点，所以可以用栈实现数制转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        S.Push(N%<span class="number">2</span>);</span><br><span class="line">        N=N/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">while</span>(!Empty(S))&#123;</span><br><span class="line">        S.pop(e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="括号匹配">括号匹配</h4><p>因为括号后面出现的右括号也是要先匹配前面最后一个左括号，也就是栈顶括号，也符合</p><h4 id="行编辑程序">行编辑程序</h4><p>用来设定输入缓冲区，根据栈顶是不是特殊字符判断什么操作</p><h4 id="迷宫求解">迷宫求解</h4><h4 id="表达式求值">表达式求值</h4><p>中缀表达式可以用符号栈和操作数栈分开</p><h3 id="函数调用栈">函数调用栈</h3><p>这个栈每个节点存储返回地址以及参数值</p><h3 id="栈与递归的实现">栈与递归的实现</h3><p>利用函数调用栈，在程序设计语言中实现递归。<br>**递归函数：**一个直接调用自己或者通过一系列调用语句间接调用自己的函数，叫做递归函数。<br>在一个函数的运行期间要调用其他函数的时候，系统需要做三件事</p><ul><li>将被调用的函数所需要的参数和执行完需要返回的地址传给被调用函数</li><li>分配存储空间给被调用函数存储局部变量</li><li>最后将控制权交给被调用函数<br>被调用函数执行完之后，保存计算结果，并释放局部变量的存储空间，返回到原先传给它的返回地址。<br>可以看出是后调用的函数先计算出结果，也就是先运行完，类似于栈的后进先出结构，所以使用函数调用栈来处理函数的调用问题。当一个函数执行完之后，就从栈顶弹出。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="专业课" scheme="https://52hert-z.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数据结构" scheme="https://52hert-z.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="考研408" scheme="https://52hert-z.github.io/tags/%E8%80%83%E7%A0%94408/"/>
    
  </entry>
  
  <entry>
    <title>计组复习计划</title>
    <link href="https://52hert-z.github.io/2021/06/29/%E8%AE%A1%E7%BB%84%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://52hert-z.github.io/2021/06/29/%E8%AE%A1%E7%BB%84%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2021-06-28T16:00:00.000Z</published>
    <updated>2021-06-30T12:16:17.972Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>总体规划</h1><ul><li>组成原理在计算机考研中非常重要，特别是针对 408 的考试，组成原理分值占 45 分，和数据结构并驾齐驱。在这门课程中，我们需要理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有计算机系统的整机概念。理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。这门课程是非记忆性的，侧重概念和原理的应用，各个章节之间也是紧密联系的，同学们要学会把所有的内容都串起来。</li><li>第一章计算机系统概述。这一章初步了解计算机执行的基本过程，这个过程贯彻到后面的各个章节，所以一定要理解透。</li><li>第二章数据的表示和运算。这一章主要有四部分内容，数制与编码、定点数的表示和运算、浮点数的表示和运算和算术逻辑单元 ALU，这一章内容比较零碎、也比较枯燥无聊，希望同学们多理解。</li><li>第三章存储器层次结构。这一章是重点章节，存储器的分类、存储器的层次结化结构、 半导体随机存取存储器主要考察概念。重点在主存储器与 CPU 的连接以及高速缓冲存储器两大块。另外，虚拟存储器有些自主命题的院校不考可以不看，408 命题喜欢将虚拟存储器和 OS 联合出题，同学们一定要重视。</li><li>第四章指令系统也是一大块考点，这一章通常会结合 CPU 系统进行考察。其中指令的寻址方式是重中之重。</li><li>第五章中央处理器是计算机的中心,也是本书的难点。其中,数据通路的分析、指令执行 阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特 点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。 但是针对不同学校第四章和第五章可能会有偏差，希望同学们参考院校大纲，有计划地进行 学习。</li><li>第六章总线的知识点较少，其中总线仲裁及总线操作和定时方式是难点。本章内容通常 以选择题的形式出现，特别是系统总线的特点、性能指标、各种仲裁方式的特点、异步定时 方式及常见的总线标准和特点等。总线带宽的计算也可能结合其他章节出综合题。</li><li>第七章结合操作系统《输入输出 I/O 管理》一起复习，磁盘存储、I/O 接口、中断以及 I/O 方式是本章节的重点。</li></ul><h1>复习要点</h1><p>六月到七月是复习计组的第一轮，复习方法偏重基础</p><ul><li>课本为主，在复习时勾画知识点，圈出重难点</li><li>看网课做好笔记，重点解决标注的重难点</li><li>课后练习有针对性做题（做好王道课后题就完事），多总结</li></ul><h1>复习进度</h1><div class="mermaid">gantt    title 计组复习进度    dateFormat YYYY-MM-DD    section 复习章节        第一章  :done, des1, 2021-06-29, 2021-06-30        第二章  :active, des2, 2021-06-30, 2021-07-01        第三章  :des3, 2021-07-01, 2021-07-02        第四章  :des4, 2021-07-02, 2021-07-08</div><ul><li>6.29 第一章计算机系统概述，看网课，王道计组复习书</li><li>6.30 看第一章课本，天勤网课</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="专业课" scheme="https://52hert-z.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="考研408" scheme="https://52hert-z.github.io/tags/%E8%80%83%E7%A0%94408/"/>
    
    <category term="计算机组成原理" scheme="https://52hert-z.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>🐔🐔计组第一章笔记</title>
    <link href="https://52hert-z.github.io/2021/06/29/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://52hert-z.github.io/2021/06/29/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2021-06-28T16:00:00.000Z</published>
    <updated>2021-07-01T12:01:09.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>复习要点</h1><p>本章是组成原理的概述，考察时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。重点在各个性能指标的计算，这部分考频很高。</p><ul><li>计算机由哪几部分组成？以哪部分为中心？</li><li>主频高的CPU一定比主频低的CPU快吗？为什么？</li><li>翻译程序、汇编程序、编译程序、解释程序有什么区别？各自的特性是什么？</li><li>不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</li></ul><h1>第一章 计算机系统概述</h1><p>三极管：高低电平控制导不导通，作为开关，表示计算机的0个1实现基本操作，实现与门、或门、异或门等<br>可以用来实现加法操作加减乘除都行</p><h2 id="计算机发展历程">计算机发展历程</h2><h3 id="计算机硬件的发展">计算机硬件的发展</h3><ol><li>ENIAC：1946第一台电子数字计算机，电子管时代（1946-1957）<br>特点：</li></ol><ul><li>逻辑元件采用电子管</li><li>使用机器语言进行编程</li><li>主存用延迟线或磁鼓存储信息，容量极小</li><li>体积庞大</li><li>运算速度较低，一般只有几千次到几万次每秒</li></ul><ol start="2"><li>第二代计算机：1958-1964，晶体管时代<br>特点：</li></ol><ul><li>逻辑元件采用晶体管</li><li>运算速度提高到几万次到几十万次</li></ul><h3 id="计算机软件的发展">计算机软件的发展</h3><p>比较次要，考的比较少</p><h2 id="计算机系统层次结构">计算机系统层次结构</h2><p>直接执行机器语言的机器成为实际机器M1：机器语言程序直接在M1上执行<br>具有将汇编语言程序翻译成机器语言程序的功能的机器M2：人们编写汇编语言程序向M2输入，而M2暗地里将汇编语言程序转换成机器语言程序交给M1去执行，所以M2实际上是一种程序，不是一种实际存在的机器，称为虚拟机<br>实际上汇编的每一条指令还是对应了一条机器语言语句，只是把奇奇怪怪的01串儿换成了人们好记住的英文单词add等，人们还是要熟悉机器语言的语句的作用跟这些语言是如何执行的，还是比较麻烦<br>所以20世纪60年代有了面向问题的高级语言，这种语言就不用去了解机器语言语句的作用了，程序员就只要理解一种高级语言的语法语义就完事儿了昂，用高级语言编写程序，然后有专门的编译程序给你整成汇编语言程序，然后由M2整成机器语言程序给M1，多了一层编译程序，但是方便了很多。这个编译程序给他起个名儿就叫高级语言机器M3，在这里根据高级语言的不同，这个机器可以是编译程序或者是解释程序。<br>编译程序：将一整个源程序全部编译优化成机器语言程序，然后再执行<br>解释程序：一句一句翻译成机器语言程序一句一句执行，搞一句就执行一句<br>机器语言机器M1还可以细分成微程序机器M0，把每一条机器语言指令换成一系列的微指令，然后每执行一条机器指令，就由M1指挥M0去执行相应的微程序，也就是说其实M0就跟M1没什么区别，就是将M1执行的指令换成微程序了。</p><ul><li>计组这门课主要讲M1跟M0，软件实现的就叫虚拟机，还有应用软件层在M3上面哈</li><li>在M1和M2之间存在着操作系统区分软件跟硬件，也就是操作系统当做桥梁架在软件（汇编程序）跟硬件（机器语言）之间。</li></ul><h3 id="区分计算机组成和计算机体系结构">区分计算机组成和计算机体系结构</h3><p>计算机体系结构就是那些能被程序员见到的计算机系统的属性，比如说指令集，数据类型，寻址技术，不同结构的计算机这些东西都是不同的，因为底层硬件就不一样。但是计算机组成就是在指令集的基础上讨论如何实现一种功能，比如说一台机器是否具备乘法指令，这就是结构方面的问题，但是如何实现乘法指令，这是一个组成问题，在一台硬件已经确定了的机器上如何发挥它的最大性能，这就是计算机组成所要解决的问题，采用不同的组成方式也就是不同的实现方式，可能会大幅度影响一台计算机的性能</p><h4 id="计算机软件和硬件的关系：">计算机软件和硬件的关系：</h4><ul><li>硬件和软件互相依存<br>硬件是软件工作的物质基础，软件的正常工作是硬件发挥作用的唯一途径</li><li>硬件和软件无严格界线<br>在许多情况下，计算机的某些功能既可以由硬件实现，也可以由软件来实现。因此，硬件与软件在一定意义上说没有严格的界线</li><li>硬件和软件协同发展<br>计算机软件随硬件技术的发展而发展，而软件的不断发展与完善又促进硬件的更新，两者交织发展，缺一不可</li></ul><h2 id="计算机的基本组成">计算机的基本组成</h2><h3 id="计算机硬件的基本组成">计算机硬件的基本组成</h3><p>冯诺依曼计算机是以运算器为中心的，而现代的计算机是以存储器为中心的。</p><h4 id="计算机的功能部件">计算机的功能部件</h4><ul><li>运算器</li><li>存储器</li><li>控制器</li><li>输入设备</li><li>输出设备</li></ul><h4 id="冯诺依曼计算机结构：">冯诺依曼计算机结构：</h4><ul><li>计算机由运算器、存储器、控制器、输入和输出设备五大部分组成</li><li>指令和数据以同等地为存放在存储器内，并可按地址寻访</li><li>指令和数据均采用二进制来表示</li><li>指令游操作码和地址码组成</li><li>指令在存储器内顺序存放。通常指顺序执行，在特定条件下，可根据运算结果或条件改变执行顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传输通过运算器完成</li></ul><h3 id="计算机系统的构成">计算机系统的构成</h3><p>存储器的工作方式是按存储单元的地址存取<br>MDR的长度等于存储单元的长度，称之为存储字长（字），即存储单元中存储基元的个数<br>存储字长可以是8位、16位、32位等，字节的二次幂的整数倍<br>每8个存储基元称之为一个字节，存储字长为字节的整数倍<br>位bit<br>字节byte<br>字word<br>MQ乘商寄存器<br>ACC累加器<br>ALU算术逻辑单元<br>X操作数寄存器<br>CU控制单元<br>IR指令寄存器：存放当前的指令<br>PC程序计数器：存放当前想要执行的指令的地址</p><h3 id="计算机的工作过程">计算机的工作过程</h3><ul><li>把程序和数据装入主存储器</li><li>将源程序转换为可执行文件</li><li>从可执行文件的首地址开始逐条执行指令</li></ul><ol><li>源程序到可执行文件<br>1）预处理：将#开头的命令处理了，比如说包含的头文件，加入到文件中，#define等等，输出一个.i文件就是包含所有需要执行的代码的程序<br>2）编译：将.i文件处理成汇编语言程序，输出.s文件<br>3）汇编：将.s翻译成机器语言程序，输出hello.o<br>4）链接：将多个可重定位目标文件和标准库函数合并为一个可执行目标文件。最终生成的可执行文件被保存在磁盘上。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="专业课" scheme="https://52hert-z.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="考研408" scheme="https://52hert-z.github.io/tags/%E8%80%83%E7%A0%94408/"/>
    
    <category term="计算机组成原理" scheme="https://52hert-z.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://52hert-z.github.io/2021/06/25/hello-world/"/>
    <id>https://52hert-z.github.io/2021/06/25/hello-world/</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-06-29T13:35:50.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>写在前面</h1><p>最近一时兴起想要建个博客，用了Jerry的butterfly框架，平时记录一下笔记，以及一些脑子一热的想法。</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="测试一下mermaid插件">测试一下mermaid插件</h3><div class="mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</div><div class="mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 计组章节        Completed task            :done,    des1, 2014-01-06,2014-01-08        Active task               :active,  des2, 2014-01-09, 3d        Future task               :         des3, after des2, 5d        Future task2               :         des4, after des3, 5d        section Critical tasks        Completed task in the critical line :crit, done, 2014-01-06,24h        Implement parser and jison          :crit, done, after des1, 2d        Create tests for parser             :crit, active, 3d        Future task in critical line        :crit, 5d        Create tests for renderer           :2d        Add to mermaid                      :1d        section Documentation        Describe gantt syntax               :active, a1, after des1, 3d        Add gantt diagram to demo page      :after a1  , 20h        Add another diagram to demo page    :doc1, after a1  , 48h        section Last section        Describe gantt syntax               :after doc1, 3d        Add gantt diagram to demo page      : 20h        Add another diagram to demo page    : 48h</div><h3 id="测试一下公式">测试一下公式</h3><p>$$<br>\lim_{x\rightarrow 0}\left ( 1+x \right )^{\frac{1}{x}}=e<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="博客搭建" scheme="https://52hert-z.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第二章笔记</title>
    <link href="https://52hert-z.github.io/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://52hert-z.github.io/2021/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-06-29T11:21:44.768Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第二章 线性表</h1><div class="mermaid">graph TD;    线性表--&gt;顺序存储;线性表--&gt;链式存储;    链式存储--&gt;单链表;    链式存储--&gt;双链表;    链式存储--&gt;循环链表;    链式存储--&gt;静态链表;    单链表--&gt;指针实现;    双链表--&gt;指针实现;    循环链表--&gt;指针实现;</div><ul><li><p>线性表是算法题命题的重点。实现容易代码量少，但是同时也要求有最优的性能（时间复杂度和空间复杂度），才能拿满分。</p></li><li><p>考试中不要求代码有实际的可执行性，只要表达出算法的思想即可，不要死抠语法细节。</p></li><li><p>在考场上实在想不出来最优解可以采用暴力解也能拿至少一半分数。</p></li></ul><h2 id="线性表的类型定义">线性表的类型定义</h2><ol><li>线性结构特点：</li></ol><ul><li>存在唯一的一个被称作“第一个”的数据元素；</li><li>除第一个之外，集合中的每一个数据元素都只有一个前驱；</li><li>除了最后一个之外，集合中的每个数据元素都只有一个后继。</li></ul><ol start="2"><li><strong>线性表</strong>是最常用且最简单的一种数据结构。<br>线性表是有n个数据元素的有限序列，这里的数据元素可以是简单的int型整数，也可以是一个结构体，由若干个数据项组成，比如说链表，含有数据域以及指针域。<br>在这种情况下，数据元素可以叫做记录，含有大量记录的线性表叫做<strong>文件</strong>。</li><li>线性表特点</li></ol><ul><li>元素个数有限</li><li>表中元素具有先后次序</li><li>元素数据类型都相同</li><li>元素具有抽象性，仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容</li></ul><h2 id="线性表的顺序表示和实现">线性表的顺序表示和实现</h2><h3 id="顺序表定义">顺序表定义</h3><ol><li>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得在逻辑上相邻的两个元素在物理上也相邻。</li><li>顺序表的特点就是表中元素的逻辑顺序和物理顺序相同。</li><li><strong>位序</strong>：数组下标加一，即表示实际第几个元素（从一开始计数）</li><li>线性表顺序存储实现</li></ol><ul><li>静态分配（长度不可变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype data[MaxSize];<span class="comment">//顺序表元素</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;Sqlist;<span class="comment">//把struct换个名字</span></span><br></pre></td></tr></table></figure><ul><li>动态分配（长度可以变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elemtype *data;</span><br><span class="line">  <span class="keyword">int</span> length, MaxSize;<span class="comment">//length：当前元素个数，MaxSize：数组最大长度（随着需要可以改变）</span></span><br><span class="line">&#125;Sqlist;</span><br><span class="line">L.data=(Elemtype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elemtype));<span class="comment">//C语言分配内存空间</span></span><br><span class="line">L.data=<span class="keyword">new</span> Elemtype[InitSize];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意C语言调用malloc函数要包含 <strong>#include&lt;stdlib.h&gt;</strong></p><ol start="5"><li>顺序表特点</li></ol><ul><li>最大特点是随机访问</li><li>存储密度高</li><li>插入删除要移动大量元素</li></ul><h3 id="顺序表基本操作实现">顺序表基本操作实现</h3><ol><li>插入操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(L.length&gt;=MaxSize)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/*注意这里判断插入位置i可以到length+1因为可以在这个位置插入（位序）</span></span><br><span class="line"><span class="comment">  而下面的移动元素数组的下标最多到length，此时数组里最后一个元素的下标是length-1</span></span><br><span class="line"><span class="comment">  因为要往后移动元素，所以要用到第length个数组位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=L.length;j&gt;=i;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j<span class="number">-1</span>];<span class="comment">//从第i个元素开始往后移动，这样数组里面L.data[i-1]就会空出来</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑时间复杂度为 $O(N)$。注意计算移动节点的平均次数。</p><ol start="2"><li>删除操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, Elemtype &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e=L.data[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&lt;L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    L.data[j]=L.data[j+<span class="number">1</span>];<span class="comment">//将第i个元素之后的元素前移</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意计算移动节点的平均次数。</p><ol start="3"><li>按值查找</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(Sqlist L, Elemtype e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(N)$，注意查找的平均比较次数。</p><h2 id="线性表的链式表示和实现">线性表的链式表示和实现</h2><p>显然，顺序表在插入删除方面有不可避免的缺点，所以链式存储应运而生，解决这个问题，但也失去了顺序存储的随机访问的优点。</p><p>线性表的链式存储也叫链表。</p><h3 id="单链表的定义">单链表的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  Elemtype data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*LinkList -&gt; LNode*</span></span><br><span class="line"><span class="comment">LinkList L;</span></span><br><span class="line"><span class="comment">LNode* L;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意这里的重命名，我们声明了一个叫做LNode的结构体，然后我们给他换个名字叫LNode，以及声明一个它的指针类型。</p><ol><li>头指针与头结点</li></ol><ul><li>头指针：指向链表第一个结点的指针，跟有没有头结点没有关系</li><li>头结点：有些定义为了方便操作，在第一个结点之前定义了一个叫做头结点的东西，该节点的指针指向第一个结点，头结点的数据域可以不存储东西，也可以存储比如说链表长度之类的东西</li></ul><ol start="2"><li>头结点的好处</li></ol><ul><li>第一个节点不用特殊处理（因为第一个节点跟其他节点一样，他的位置存放在上一个节点的next指针里，如果不使用头结点，那么第一个节点就要特殊处理，做题的时候注意审题），比如说在第一个结点前插入新节点或者说删除第一个结点我们都需要更改头指针的指向，非常麻烦。</li><li>非空表和空表的处理得到统一（因为无论是不是空表，头指针都是非空的），比如说一个不带头结点的空链表要插入一个结点，不带头结点的链表在第一个位置插入新节点，虽然都是在同一个位置插入，但是操作是不一样的，非常麻烦，容易出bug</li><li>总的来说就是没有头结点的时候，对于第一个结点的操作跟其他节点都是不一样的，每个操作都要考虑特殊情况，有头结点就没这么多鸟事</li></ul><ol start="3"><li>头插法建立单链表</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L-&gt;next;<span class="comment">//两步指针插入</span></span><br><span class="line">    L-&gt;next=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L;<span class="comment">//两步指针插入</span></span><br><span class="line">    L=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要创建头结点以及插入的时候先指向头指针所指向的节点（第一个结点），然后再将头指针指向新节点。</p><p>需要注意的是，头插法输入数据的顺序跟在链表中的顺序是相反的，可以用来将元素逆序。</p><ol start="4"><li>尾插法</li></ol><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">  LNode *s, *r=L;<span class="comment">//r为表尾指针</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//这里设置的终止条件是输入9999</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    r-&gt;next=s;<span class="comment">//两步指针插入</span></span><br><span class="line">    r=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><p>思考</p><ol start="5"><li>按位查找</li><li>按值查找</li><li>插入结点</li><li>删除结点</li><li>求表长</li></ol><h3 id="双链表">双链表</h3><p>单链表有个缺点就是要找一个结点的前驱非常麻烦，要从头遍历，所以有了双链表，在结构体的指针域中增加一个指向前一个结点的指针，注意头结点的前驱指针指向空。</p><ol><li>插入</li><li>删除</li></ol><h3 id="循环链表">循环链表</h3><h4 id="循环单链表">循环单链表</h4><p>与单链表唯一的不同就是尾结点的next指针指向了头结点，变成了一个环。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="专业课" scheme="https://52hert-z.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数据结构" scheme="https://52hert-z.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="考研408" scheme="https://52hert-z.github.io/tags/%E8%80%83%E7%A0%94408/"/>
    
  </entry>
  
</feed>
